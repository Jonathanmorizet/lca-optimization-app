# -*- coding: utf-8 -*-
"""NSGA working.ipynb

Automatically generated by Colab.

Original file is located at
https://colab.research.google.com/drive/1gj4msN3M3OSrWT7x9RuzsVLJiYgagmUW

## Summary:

### Data Analysis Key Findings

*   The NSGA-II algorithm was successfully implemented to optimize material inputs, considering both total material cost and multiple TRACI impact categories simultaneously.
*   The optimization identified a set of non-dominated solutions (Pareto front) representing various trade-offs between minimizing cost and minimizing each of the nine TRACI environmental impacts.
*   As shown in the output, solutions on the Pareto front demonstrate the expected multi-objective trade-off: solutions with lower total costs generally exhibit higher values across the TRACI impact categories, and conversely, solutions with lower environmental impacts tend to have higher total costs. For example, Solution 1 has a cost of \$545.44 but relatively high impact values (e.g., 'kg CO2-Eq/Unit': 1132.0920), while Solution 15 has a much higher cost of \$686.39 but significantly lower impact values (e.g., 'kg CO2-Eq/Unit': 976.0590).

### Insights or Next Steps

*   Due to the high dimensionality (10 objectives), a simple 2D scatter plot cannot fully represent the Pareto front. Further analysis or visualization techniques (e.g., parallel coordinate plots, radar charts) could be used to better understand the relationships and trade-offs among all ten objectives across the Pareto front solutions.
*   The solutions on the Pareto front represent optimal material input combinations under the given constraints (+/- 20% of base amounts). Decision-makers can choose a solution from this front based on their specific priorities regarding cost versus environmental impact.
"""


from google.colab import files
import pandas as pd

# Upload your Excel file
uploaded = files.upload()

# Extract the uploaded filename
file_name = list(uploaded.keys())[0]

# Read sheets
inputs_df = pd.read_excel(file_name, sheet_name=0)
cost_df = pd.read_excel(file_name, sheet_name=1)
impact_df = pd.read_excel(file_name, sheet_name=2)

# Show previews
inputs_df.head(), cost_df.head(), impact_df.head()

import pandas as pd
import numpy as np
from deap import base, creator, tools, algorithms
import random

# Load the file
file_path = "DEAP NSGA Readable file.xlsm"
inputs_df = pd.read_excel(file_path, sheet_name=0)
cost_df = pd.read_excel(file_path, sheet_name=1)
impact_df = pd.read_excel(file_path, sheet_name=2)

# === Prepare Data ===
# Merge inputs with costs and impacts, keeping all inputs and adding cost/impact if available
merged_df = inputs_df.merge(cost_df, on=['Material', 'Unit'], how='left')
merged_df = merged_df.merge(impact_df, on=['Material', 'Unit'], how='left')

# Fill missing costs or impacts with 0. We assume materials without listed costs/impacts
# have negligible cost/impact in this context.
cost_col = 'Unit Cost ($)'
impact_cols = [col for col in impact_df.columns if col not in ['Material', 'Unit']]

merged_df[cost_col] = merged_df[cost_col].fillna(0)
for col in impact_cols:
    merged_df[col] = merged_df[col].fillna(0)

    # Ensure amounts are also non-negative after any potential merging/filling
    merged_df['Amount'] = merged_df['Amount'].apply(lambda x: max(0, x))


    materials = merged_df['Material'].tolist()
    base_amounts = merged_df['Amount'].values
    costs = merged_df[cost_col].values
    impact_matrix = merged_df[impact_cols].values

    # === NSGA-II Setup ===
    POP_SIZE = 50
    NGEN = 40
    MUTPB = 0.3 # Increased mutation probability slightly
    CXPB = 0.6 # Increased crossover probability slightly
    random.seed(42) # for reproducibility

    # Attempt to delete previously created classes to avoid RuntimeWarning
    try:
        del creator.FitnessMin
        del creator.Individual
        except AttributeError:
            pass

            creator.create("FitnessMin", base.Fitness, weights=(-1.0, -1.0))  # Minimize both cost & GWP
            creator.create("Individual", list, fitness=creator.FitnessMin)

            toolbox = base.Toolbox()

            # Sensitivity bounds: +/- 20% of base amount, ensuring non-negativity
            low_bounds = base_amounts * 0.8
            high_bounds = base_amounts * 1.2

            # Ensure lower bound is not negative
            low_bounds[low_bounds < 0] = 0

            # Attribute generator: random value within bounds, ensuring non-negativity
            def create_ind():
                return [random.uniform(low, high) for low, high in zip(low_bounds, high_bounds)]

                toolbox.register("individual", tools.initIterate, creator.Individual, create_ind)
                toolbox.register("population", tools.initRepeat, list, toolbox.individual)

                # Evaluation function: (Total Cost, Total GWP)
                def evaluate(individual):
                    # Ensure non-negativity of individual values before calculation - this was a workaround,
                    # the bounds should be enforced on the individual itself.
                    adjusted_amounts = np.array(individual) # Use the individual's values directly

                    total_cost = np.dot(adjusted_amounts, costs)

                    # Find the index for the GWP column ('kg CO2-Eq/Unit')
                    try:
                        gwp_idx = impact_cols.index("kg CO2-Eq/Unit")
                        total_gwp = np.dot(adjusted_amounts, impact_matrix[:, gwp_idx])
                        except ValueError:
                            print("Warning: 'kg CO2-Eq/Unit' not found in impact columns. GWP will be 0.")
                            total_gwp = 0.0

                            return total_cost, total_gwp

                            toolbox.register("evaluate", evaluate)

                            # Bounding function to apply after crossover and mutation
                            def bound_individual(individual, low_bounds, high_bounds):
                                for i in range(len(individual)):
                                    individual[i] = max(low_bounds[i], min(high_bounds[i], individual[i]))
                                    return individual

                                    # Crossover operator: Apply blend crossover and then explicitly bound
                                    def custom_crossover(ind1, ind2, alpha):
                                        child1, child2 = tools.cxBlend(ind1, ind2, alpha)
                                        # Explicitly apply bounding to children
                                        child1 = bound_individual(child1, low_bounds, high_bounds)
                                        child2 = bound_individual(child2, low_bounds, high_bounds)
                                        return child1, child2

                                        toolbox.register("mate", custom_crossover, alpha=0.5)

                                        # Mutation operator: Apply Gaussian mutation and then explicitly bound
                                        def custom_mutate(individual, mu, sigma, indpb):
                                            mutated_individual, = tools.mutGaussian(individual, mu, sigma, indpb)
                                            # Explicitly apply bounding to mutated individual
                                            mutated_individual = bound_individual(mutated_individual, low_bounds, high_bounds)
                                            return mutated_individual, # Return as tuple

                                            toolbox.register("mutate", custom_mutate, mu=0, sigma=0.1, indpb=0.2)
                                            toolbox.register("select", tools.selNSGA2)

                                            # === Run Optimization ===
                                            pop = toolbox.population(n=POP_SIZE)

                                            # Evaluate the initial population
                                            fitnesses = list(map(toolbox.evaluate, pop))
                                            for ind, fit in zip(pop, fitnesses):
                                                ind.fitness.values = fit

                                                # This is the main NSGA-II algorithm
                                                algorithms.eaMuPlusLambda(pop, toolbox, mu=POP_SIZE, lambda_=POP_SIZE,
                                                cxpb=CXPB, mutpb=MUTPB, ngen=NGEN, verbose=True)


                                                # === Extract Pareto-Optimal Solutions ===
                                                # Get the first front (non-dominated solutions)
                                                pareto_front = tools.sortNondominated(pop, k=len(pop), first_front_only=True)[0]

                                                # Sort the Pareto front for better readability (e.g., by cost)
                                                sorted_front = sorted(pareto_front, key=lambda x: x.fitness.values[0])

                                                # Display top solutions (using actual calculated values)
                                                print("\nPareto Front Solutions (Actual Total Cost, Actual Total GWP):")
                                                for ind in sorted_front:
                                                    actual_cost, actual_gwp = toolbox.evaluate(ind)
                                                    print(f"(Cost: {actual_cost:.2f}, GWP: {actual_gwp:.4f})")

                                                    # Install if not already (skip if done)
                                                    # !pip install deap pandas numpy openpyxl

                                                    import pandas as pd
                                                    import numpy as np
                                                    from deap import base, creator, tools, algorithms
                                                    import random

                                                    # === Load Data ===
                                                    file_path = "DEAP NSGA Readable file.xlsm"
                                                    inputs_df = pd.read_excel(file_path, sheet_name=0)
                                                    cost_df = pd.read_excel(file_path, sheet_name=1)
                                                    impact_df = pd.read_excel(file_path, sheet_name=2)

                                                    # === Merge Inputs with Costs and Impacts ===
                                                    merged_df = inputs_df.merge(cost_df, on=["Material", "Unit"], how="left")
                                                    merged_df = merged_df.merge(impact_df, on=["Material", "Unit"], how="left")

                                                    # Drop any rows with missing values to ensure integrity
                                                    merged_df = merged_df.dropna()

                                                    # === Prepare Data for Optimization ===
                                                    materials = merged_df['Material'].tolist()
                                                    base_amounts = merged_df['Amount'].values
                                                    costs = merged_df['Unit Cost ($)'].values
                                                    impact_columns = [col for col in impact_df.columns if col not in ['Material', 'Unit']]
                                                    impact_matrix = merged_df[impact_columns].values

                                                    # === NSGA-II Setup ===
                                                    POP_SIZE = 50
                                                    N_GEN = 40
                                                    random.seed(42)

                                                    creator.create("FitnessMulti", base.Fitness, weights=(-1.0, -1.0))  # Minimize cost and GWP
                                                    creator.create("Individual", list, fitness=creator.FitnessMulti)

                                                    toolbox = base.Toolbox()

                                                    # Sensitivity bounds: +/- 20% of base amount
                                                    low_bounds = base_amounts * 0.8
                                                    high_bounds = base_amounts * 1.2

                                                    # Attribute generator: random value within bounds
                                                    def create_ind():
                                                        return [random.uniform(low, high) for low, high in zip(low_bounds, high_bounds)]

                                                        toolbox.register("individual", tools.initIterate, creator.Individual, create_ind)
                                                        toolbox.register("population", tools.initRepeat, list, toolbox.individual)

                                                        # Evaluation: (Total Cost, Total GWP)
                                                        def evaluate(ind):
                                                            ind_array = np.array(ind)
                                                            total_cost = np.dot(ind_array, costs)

                                                            try:
                                                                gwp_idx = impact_columns.index("kg CO2-Eq/Unit")
                                                                total_gwp = np.dot(ind_array, impact_matrix[:, gwp_idx])
                                                                except:
                                                                    total_gwp = float('inf')  # If GWP column not found

                                                                    return total_cost, total_gwp

                                                                    toolbox.register("evaluate", evaluate)
                                                                    toolbox.register("mate", tools.cxBlend, alpha=0.5)
                                                                    toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=0.1, indpb=0.2)
                                                                    toolbox.register("select", tools.selNSGA2)

                                                                    # === Run NSGA-II ===
                                                                    pop = toolbox.population(n=POP_SIZE)
                                                                    algorithms.eaMuPlusLambda(pop, toolbox, mu=POP_SIZE, lambda_=POP_SIZE,
                                                                    cxpb=0.6, mutpb=0.3, ngen=N_GEN, verbose=True)

                                                                    # === Extract Pareto-Optimal Solutions ===
                                                                    pareto_front = tools.sortNondominated(pop, k=len(pop), first_front_only=True)[0]

                                                                    # Display top solutions
                                                                    sorted_front = sorted(pareto_front, key=lambda x: (x.fitness.values[0], x.fitness.values[1]))
                                                                    print("\nTop 5 Solutions (Total Cost, Total GWP):")
                                                                    for ind in sorted_front[:5]:
                                                                        print(ind.fitness.values)

                                                                        # Re-define the evaluate function within this cell to ensure it uses the current data
                                                                        def evaluate(individual):
                                                                            # Ensure non-negativity of individual values before calculation
                                                                            adjusted_amounts = np.maximum(0, np.array(individual))

                                                                            # Ensure costs and impact_matrix are aligned with the individual's length
                                                                            # Although they should be if generated from the same merged_df
                                                                            if len(adjusted_amounts) != len(costs):
                                                                                print("Warning: Length of individual does not match length of costs.")
                                                                                return (float('inf'),) * (1 + impact_matrix.shape[1]) # Return infinity for all objectives if mismatch

                                                                                total_cost = np.dot(adjusted_amounts, costs)

                                                                                # Calculate total impact for each TRACI impact category
                                                                                total_impacts = []
                                                                                for i in range(impact_matrix.shape[1]): # Iterate based on the actual shape of impact_matrix
                                                                                    total_impact = np.dot(adjusted_amounts, impact_matrix[:, i])
                                                                                    total_impacts.append(total_impact)


                                                                                    # Return a tuple of total cost and all total impacts
                                                                                    return (total_cost,) + tuple(total_impacts)


                                                                                    # Display the optimized material inputs for each solution on the Pareto front
                                                                                    print("\nOptimized Material Inputs for Pareto Front Solutions:")
                                                                                    for i, ind in enumerate(sorted_front):
                                                                                        # Calculate actual cost and GWP using the evaluate function
                                                                                        # Note: We use the re-defined evaluate function in this cell
                                                                                        actual_cost, actual_gwp = evaluate(ind)[:2] # Get only the first two objectives (Cost and GWP) for display

                                                                                        print(f"\nSolution {i+1} (Actual Total Cost: {actual_cost:.2f}, Actual Total GWP: {actual_gwp:.4f}):")
                                                                                        # Display optimized amounts alongside base amounts for comparison
                                                                                        optimized_inputs = pd.DataFrame({'Material': materials, 'Base Amount': base_amounts, 'Optimized Amount': ind})
                                                                                        print(optimized_inputs)

                                                                                        import matplotlib.pyplot as plt

                                                                                        # Extract cost and GWP values from the Pareto front solutions
                                                                                        costs = [ind.fitness.values[0] for ind in sorted_front]
                                                                                        gwps = [ind.fitness.values[1] for ind in sorted_front]

                                                                                        # Create the scatter plot
                                                                                        plt.figure(figsize=(10, 6))
                                                                                        plt.scatter(costs, gwps, marker='o', color='b', label='Pareto Front Solutions')
                                                                                        plt.title('Pareto Front: Total Cost vs. Total GWP')
                                                                                        plt.xlabel('Total Cost ($)')
                                                                                        plt.ylabel('Total GWP (kg CO2-Eq)')
                                                                                        plt.grid(True)
                                                                                        plt.legend()
                                                                                        plt.show()

                                                                                        """# Task
                                                                                        Optimize material input parameters +/- 20% based on material cost per unit and every single TRACI impact per unit from "Material_Data.xlsx" and "Impact_Data.xlsx" using NSGA-II, and display the Pareto front showing cost vs. each TRACI impact.

                                                                                        ## Identify impact objectives

                                                                                        ### Subtask:
                                                                                        Determine all the TRACI impact columns in the `impact_df`.

                                                                                        **Reasoning**:
                                                                                        Extract the column names from the impact_df DataFrame that are not 'Material' or 'Unit' and store them in a list to identify the TRACI impact categories.
                                                                                        """

                                                                                        traci_impact_cols = [col for col in impact_df.columns if col not in ['Material', 'Unit']]
                                                                                        print("TRACI Impact Columns:")
                                                                                        print(traci_impact_cols)

                                                                                        """## Update nsga-ii setup

                                                                                        ### Subtask:
                                                                                        Modify the `creator.create("FitnessMin", ...)` to include a weight for cost and a weight for each identified TRACI impact objective. Update the number of objectives the algorithm is minimizing.

                                                                                        **Reasoning**:
                                                                                        Define the fitness weights, delete existing creator classes, and create new ones with the specified weights and objectives.
                                                                                        """

                                                                                        # Define fitness weights: -1.0 for cost, and -1.0 for each TRACI impact
                                                                                        # The first objective is cost, followed by each TRACI impact
                                                                                        traci_impact_cols = [col for col in impact_df.columns if col not in ['Material', 'Unit']]
                                                                                        fitness_weights = [-1.0] + [-1.0] * len(traci_impact_cols)

                                                                                        # Attempt to delete previously created classes to avoid RuntimeWarning
                                                                                        try:
                                                                                            del creator.FitnessMin
                                                                                            except AttributeError:
                                                                                                pass
                                                                                                try:
                                                                                                    del creator.Individual
                                                                                                    except AttributeError:
                                                                                                        pass


                                                                                                        # Create Fitness class with multiple objectives to minimize
                                                                                                        creator.create("FitnessMin", base.Fitness, weights=tuple(fitness_weights))

                                                                                                        # Create Individual class
                                                                                                        creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                        """## Update evaluation function

                                                                                                        ### Subtask:
                                                                                                        Modify the `evaluate` function to calculate the total cost and the total impact for *each* TRACI impact category based on the individual's material amounts and the corresponding cost and impact data. The function should return a tuple of all objective values.

                                                                                                        **Reasoning**:
                                                                                                        Redefine the evaluate function to calculate total cost and total impact for each TRACI impact category.
                                                                                                        """

                                                                                                        def evaluate(individual):
                                                                                                            # Ensure non-negativity of individual values before calculation
                                                                                                            adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                            total_cost = np.dot(adjusted_amounts, costs)

                                                                                                            # Calculate total impact for each TRACI impact category
                                                                                                            total_impacts = []
                                                                                                            for i, col in enumerate(traci_impact_cols):
                                                                                                                total_impact = np.dot(adjusted_amounts, impact_matrix[:, i])
                                                                                                                total_impacts.append(total_impact)

                                                                                                                # Return a tuple of total cost and all total impacts
                                                                                                                return (total_cost,) + tuple(total_impacts)

                                                                                                                toolbox.register("evaluate", evaluate)

                                                                                                                """## Run multi-objective optimization

                                                                                                                ### Subtask:
                                                                                                                Execute the NSGA-II algorithm with the updated fitness definition and evaluation function.

                                                                                                                **Reasoning**:
                                                                                                                Initialize the population, evaluate the initial population, and run the NSGA-II algorithm with the updated fitness definition and evaluation function.
                                                                                                                """

                                                                                                                # === Prepare Data for Optimization (Ensure alignment) ===
                                                                                                                # Re-extract costs and impact_matrix from merged_df to ensure alignment
                                                                                                                materials = merged_df['Material'].tolist()
                                                                                                                base_amounts = merged_df['Amount'].values
                                                                                                                costs = merged_df['Unit Cost ($)'].values

                                                                                                                # Define impact columns based *only* on columns present in merged_df that are from impact_df
                                                                                                                impact_columns = [col for col in impact_df.columns if col in merged_df.columns and col not in ['Material', 'Unit']]
                                                                                                                impact_matrix = merged_df[impact_columns].values

                                                                                                                # Redefine traci_impact_cols to match the actual impact columns used
                                                                                                                traci_impact_cols = impact_columns

                                                                                                                # Define fitness weights: -1.0 for cost, and -1.0 for each TRACI impact
                                                                                                                fitness_weights = [-1.0] + [-1.0] * len(traci_impact_cols)

                                                                                                                # Attempt to delete previously created classes to avoid RuntimeWarning
                                                                                                                try:
                                                                                                                    del creator.FitnessMin
                                                                                                                    except AttributeError:
                                                                                                                        pass
                                                                                                                        try:
                                                                                                                            del creator.Individual
                                                                                                                            except AttributeError:
                                                                                                                                pass

                                                                                                                                # Create Fitness class with multiple objectives to minimize
                                                                                                                                creator.create("FitnessMin", base.Fitness, weights=tuple(fitness_weights))

                                                                                                                                # Create Individual class
                                                                                                                                creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                                                # Re-register the evaluate function with the corrected impact_matrix and traci_impact_cols
                                                                                                                                def evaluate(individual):
                                                                                                                                    # Ensure non-negativity of individual values before calculation
                                                                                                                                    adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                    total_cost = np.dot(adjusted_amounts, costs)

                                                                                                                                    # Calculate total impact for each TRACI impact category
                                                                                                                                    total_impacts = []
                                                                                                                                    for i in range(impact_matrix.shape[1]): # Iterate based on the actual shape of impact_matrix
                                                                                                                                        total_impact = np.dot(adjusted_amounts, impact_matrix[:, i])
                                                                                                                                        total_impacts.append(total_impact)


                                                                                                                                        # Return a tuple of total cost and all total impacts
                                                                                                                                        return (total_cost,) + tuple(total_impacts)

                                                                                                                                        toolbox.register("evaluate", evaluate)

                                                                                                                                        # NSGA-II Setup (ensure toolbox uses updated components)
                                                                                                                                        # Re-register individual and population as the creator classes were deleted and recreated
                                                                                                                                        toolbox.register("individual", tools.initIterate, creator.Individual, create_ind)
                                                                                                                                        toolbox.register("population", tools.initRepeat, list, toolbox.individual)

                                                                                                                                        # Ensure mate and mutate are registered (they might have been in a previous cell,
                                                                                                                                        # but re-registering here ensures they are available to this toolbox instance)
                                                                                                                                        # Assuming custom_crossover and custom_mutate are defined in a previous cell
                                                                                                                                        # If not, their definitions would also need to be moved here or ensured they are in scope.
                                                                                                                                        # Based on the notebook state, they are defined in r43WIBYbmPPy.
                                                                                                                                        # Let's assume they are in scope for now, but if errors persist, move them here.
                                                                                                                                        # For robustness, let's re-register using the standard DEAP operators if custom ones cause issues,
                                                                                                                                        # or ensure the custom ones are properly defined and in scope.
                                                                                                                                        # Given the previous errors related to bounding, let's ensure the custom operators are used.
                                                                                                                                        # The custom operators (custom_crossover, custom_mutate) are defined in cell r43WIBYbmPPy.
                                                                                                                                        # To ensure they are used by *this* toolbox instance, we should re-register them here.
                                                                                                                                        # However, re-defining them here would require copying their code.
                                                                                                                                        # A simpler approach is to ensure the toolbox is defined *after* the custom operators
                                                                                                                                        # are defined and before they are registered.

                                                                                                                                        # Let's assume toolbox is defined in r43WIBYbmPPy after custom operators.
                                                                                                                                        # If not, we might need to redefine toolbox here.
                                                                                                                                        # Based on the notebook state, toolbox is defined in r43WIBYbmPPy.
                                                                                                                                        # Let's re-register mate and mutate using the custom functions.
                                                                                                                                        # This assumes custom_crossover and custom_mutate are in the global scope
                                                                                                                                        # due to previous cell executions.
                                                                                                                                        toolbox.register("mate", custom_crossover, alpha=0.5)
                                                                                                                                        toolbox.register("mutate", custom_mutate, mu=0, sigma=0.1, indpb=0.2)

                                                                                                                                        toolbox.register("select", tools.selNSGA2)


                                                                                                                                        # === Run NSGA-II ===
                                                                                                                                        pop = toolbox.population(n=POP_SIZE)

                                                                                                                                        # Evaluate the initial population
                                                                                                                                        fitnesses = list(map(toolbox.evaluate, pop))
                                                                                                                                        for ind, fit in zip(pop, fitnesses):
                                                                                                                                            ind.fitness.values = fit

                                                                                                                                            # This is the main NSGA-II algorithm
                                                                                                                                            algorithms.eaMuPlusLambda(pop, toolbox, mu=POP_SIZE, lambda_=POP_SIZE,
                                                                                                                                            cxpb=0.6, mutpb=0.3, ngen=NGEN, verbose=True)

                                                                                                                                            """**Reasoning**:
                                                                                                                                            The error indicates a mismatch in the shapes of the `adjusted_amounts` and `costs` arrays during the dot product calculation in the `evaluate` function. This likely means the `costs` array was not properly aligned with the materials after merging and potentially dropping rows with missing values in a previous step. I need to regenerate the `costs` and `impact_matrix` from the `merged_df` *after* any potential row dropping or filling of missing values to ensure they correspond to the materials in the `merged_df`.


                                                                                                                                            """

                                                                                                                                            # === Prepare Data for Optimization ===
                                                                                                                                            # Re-extract costs and impact_matrix from merged_df to ensure alignment
                                                                                                                                            materials = merged_df['Material'].tolist()
                                                                                                                                            base_amounts = merged_df['Amount'].values
                                                                                                                                            costs = merged_df['Unit Cost ($)'].values
                                                                                                                                            impact_columns = [col for col in impact_df.columns if col not in ['Material', 'Unit']]
                                                                                                                                            impact_matrix = merged_df[impact_columns].values

                                                                                                                                            # === Run NSGA-II ===
                                                                                                                                            pop = toolbox.population(n=POP_SIZE)

                                                                                                                                            # Evaluate the initial population
                                                                                                                                            fitnesses = list(map(toolbox.evaluate, pop))
                                                                                                                                            for ind, fit in zip(pop, fitnesses):
                                                                                                                                                ind.fitness.values = fit

                                                                                                                                                # This is the main NSGA-II algorithm
                                                                                                                                                algorithms.eaMuPlusLambda(pop, toolbox, mu=POP_SIZE, lambda_=POP_SIZE,
                                                                                                                                                cxpb=0.6, mutpb=0.3, ngen=NGEN, verbose=True)

                                                                                                                                                """**Reasoning**:
                                                                                                                                                The assertion error "Assigned values have not the same length than fitness weights" indicates that the number of values returned by the `evaluate` function does not match the number of weights defined in the `creator.FitnessMin` class. This is likely because the `traci_impact_cols` variable used to define the fitness weights in a previous step was not updated after potentially dropping rows with missing values in the `merged_df`. I need to redefine the `traci_impact_cols` based on the current `merged_df` and then redefine the `FitnessMin` class with the correct number of weights before running the NSGA-II algorithm.


                                                                                                                                                """

                                                                                                                                                # Re-define traci_impact_cols based on the current merged_df
                                                                                                                                                traci_impact_cols = [col for col in impact_df.columns if col not in ['Material', 'Unit'] and col in merged_df.columns]

                                                                                                                                                # Define fitness weights: -1.0 for cost, and -1.0 for each TRACI impact
                                                                                                                                                # The first objective is cost, followed by each TRACI impact
                                                                                                                                                fitness_weights = [-1.0] + [-1.0] * len(traci_impact_cols)

                                                                                                                                                # Attempt to delete previously created classes to avoid RuntimeWarning
                                                                                                                                                try:
                                                                                                                                                    del creator.FitnessMin
                                                                                                                                                    except AttributeError:
                                                                                                                                                        pass
                                                                                                                                                        try:
                                                                                                                                                            del creator.Individual
                                                                                                                                                            except AttributeError:
                                                                                                                                                                pass

                                                                                                                                                                # Create Fitness class with multiple objectives to minimize
                                                                                                                                                                creator.create("FitnessMin", base.Fitness, weights=tuple(fitness_weights))

                                                                                                                                                                # Create Individual class
                                                                                                                                                                creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                                                                                # Re-register the evaluate function with the potentially updated impact_matrix size
                                                                                                                                                                def evaluate(individual):
                                                                                                                                                                    # Ensure non-negativity of individual values before calculation
                                                                                                                                                                    adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                    total_cost = np.dot(adjusted_amounts, costs)

                                                                                                                                                                    # Calculate total impact for each TRACI impact category
                                                                                                                                                                    total_impacts = []
                                                                                                                                                                    for i, col in enumerate(traci_impact_cols):
                                                                                                                                                                        # Ensure the column exists in the current impact_matrix
                                                                                                                                                                        if i < impact_matrix.shape[1]:
                                                                                                                                                                            total_impact = np.dot(adjusted_amounts, impact_matrix[:, i])
                                                                                                                                                                            total_impacts.append(total_impact)
                                                                                                                                                                            else:
                                                                                                                                                                                # If the column is missing in the current impact_matrix, append a placeholder (e.g., 0 or inf)
                                                                                                                                                                                total_impacts.append(0.0) # Or float('inf') depending on desired behavior

                                                                                                                                                                                # Return a tuple of total cost and all total impacts
                                                                                                                                                                                return (total_cost,) + tuple(total_impacts)

                                                                                                                                                                                toolbox.register("evaluate", evaluate)


                                                                                                                                                                                # === Prepare Data for Optimization ===
                                                                                                                                                                                # Re-extract costs and impact_matrix from merged_df to ensure alignment
                                                                                                                                                                                materials = merged_df['Material'].tolist()
                                                                                                                                                                                base_amounts = merged_df['Amount'].values
                                                                                                                                                                                costs = merged_df['Unit Cost ($)'].values
                                                                                                                                                                                # Ensure impact_columns is based on the columns actually present in merged_df
                                                                                                                                                                                impact_columns = [col for col in impact_df.columns if col not in ['Material', 'Unit'] and col in merged_df.columns]
                                                                                                                                                                                impact_matrix = merged_df[impact_columns].values


                                                                                                                                                                                # === Run NSGA-II ===
                                                                                                                                                                                pop = toolbox.population(n=POP_SIZE)

                                                                                                                                                                                # Evaluate the initial population
                                                                                                                                                                                fitnesses = list(map(toolbox.evaluate, pop))
                                                                                                                                                                                for ind, fit in zip(pop, fitnesses):
                                                                                                                                                                                    ind.fitness.values = fit

                                                                                                                                                                                    # This is the main NSGA-II algorithm
                                                                                                                                                                                    algorithms.eaMuPlusLambda(pop, toolbox, mu=POP_SIZE, lambda_=POP_SIZE,
                                                                                                                                                                                    cxpb=0.6, mutpb=0.3, ngen=NGEN, verbose=True)

                                                                                                                                                                                    """**Reasoning**:
                                                                                                                                                                                    The "AssertionError: Assigned values have not the same length than fitness weights" persists. This confirms the number of objectives returned by the `evaluate` function still doesn't match the number of weights in `creator.FitnessMin`. While I updated `traci_impact_cols` based on `merged_df.columns` for defining weights, the `evaluate` function uses the global `impact_matrix` which might not be aligned if rows were dropped in `merged_df` but the original `impact_df` was used to define the columns. I need to make sure that the `impact_columns` used to create the `impact_matrix` and the `traci_impact_cols` used for the fitness weights and within the `evaluate` function are consistent and reflect the actual columns and rows in `merged_df` after the merge and potential dropping of rows. I will regenerate `traci_impact_cols` and `impact_matrix` right before running the optimization to ensure they are based on the final state of `merged_df`.


                                                                                                                                                                                    """

                                                                                                                                                                                    # === Prepare Data for Optimization (Ensure alignment) ===
                                                                                                                                                                                    materials = merged_df['Material'].tolist()
                                                                                                                                                                                    base_amounts = merged_df['Amount'].values
                                                                                                                                                                                    costs = merged_df['Unit Cost ($)'].values

                                                                                                                                                                                    # Define impact columns based *only* on columns present in merged_df that are from impact_df
                                                                                                                                                                                    impact_columns = [col for col in impact_df.columns if col in merged_df.columns and col not in ['Material', 'Unit']]
                                                                                                                                                                                    impact_matrix = merged_df[impact_columns].values

                                                                                                                                                                                    # Redefine traci_impact_cols to match the actual impact columns used
                                                                                                                                                                                    traci_impact_cols = impact_columns

                                                                                                                                                                                    # Define fitness weights: -1.0 for cost, and -1.0 for each TRACI impact
                                                                                                                                                                                    fitness_weights = [-1.0] + [-1.0] * len(traci_impact_cols)

                                                                                                                                                                                    # Attempt to delete previously created classes to avoid RuntimeWarning
                                                                                                                                                                                    try:
                                                                                                                                                                                        del creator.FitnessMin
                                                                                                                                                                                        except AttributeError:
                                                                                                                                                                                            pass
                                                                                                                                                                                            try:
                                                                                                                                                                                                del creator.Individual
                                                                                                                                                                                                except AttributeError:
                                                                                                                                                                                                    pass

                                                                                                                                                                                                    # Create Fitness class with multiple objectives to minimize
                                                                                                                                                                                                    creator.create("FitnessMin", base.Fitness, weights=tuple(fitness_weights))

                                                                                                                                                                                                    # Create Individual class
                                                                                                                                                                                                    creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                                                                                                                    # Re-register the evaluate function with the corrected impact_matrix and traci_impact_cols
                                                                                                                                                                                                    def evaluate(individual):
                                                                                                                                                                                                        # Ensure non-negativity of individual values before calculation
                                                                                                                                                                                                        adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                                                        total_cost = np.dot(adjusted_amounts, costs)

                                                                                                                                                                                                        # Calculate total impact for each TRACI impact category
                                                                                                                                                                                                        total_impacts = []
                                                                                                                                                                                                        for i in range(impact_matrix.shape[1]): # Iterate based on the actual shape of impact_matrix
                                                                                                                                                                                                            total_impact = np.dot(adjusted_amounts, impact_matrix[:, i])
                                                                                                                                                                                                            total_impacts.append(total_impact)


                                                                                                                                                                                                            # Return a tuple of total cost and all total impacts
                                                                                                                                                                                                            return (total_cost,) + tuple(total_impacts)

                                                                                                                                                                                                            toolbox.register("evaluate", evaluate)

                                                                                                                                                                                                            # NSGA-II Setup (ensure toolbox uses updated components)
                                                                                                                                                                                                            toolbox.register("individual", tools.initIterate, creator.Individual, create_ind)
                                                                                                                                                                                                            toolbox.register("population", tools.initRepeat, list, toolbox.individual)
                                                                                                                                                                                                            toolbox.register("mate", tools.cxBlend, alpha=0.5)
                                                                                                                                                                                                            toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=0.1, indpb=0.2)
                                                                                                                                                                                                            toolbox.register("select", tools.selNSGA2)


                                                                                                                                                                                                            # === Run NSGA-II ===
                                                                                                                                                                                                            pop = toolbox.population(n=POP_SIZE)

                                                                                                                                                                                                            # Evaluate the initial population
                                                                                                                                                                                                            fitnesses = list(map(toolbox.evaluate, pop))
                                                                                                                                                                                                            for ind, fit in zip(pop, fitnesses):
                                                                                                                                                                                                                ind.fitness.values = fit

                                                                                                                                                                                                                # This is the main NSGA-II algorithm
                                                                                                                                                                                                                algorithms.eaMuPlusLambda(pop, toolbox, mu=POP_SIZE, lambda_=POP_SIZE,
                                                                                                                                                                                                                cxpb=0.6, mutpb=0.3, ngen=NGEN, verbose=True)

                                                                                                                                                                                                                """## Extract and display pareto front

                                                                                                                                                                                                                ### Subtask:
                                                                                                                                                                                                                Extract the non-dominated solutions (Pareto front). Display the objective values (Cost and each Impact Category) for the solutions on the Pareto front. Note that visualizing a Pareto front with more than two objectives is more complex than a 2D scatter plot.

                                                                                                                                                                                                                **Reasoning**:
                                                                                                                                                                                                                Extract the non-dominated solutions (Pareto front) from the final population, sort them by cost, and then iterate through the sorted solutions to print their objective values (Cost and each TRACI Impact).
                                                                                                                                                                                                                """

                                                                                                                                                                                                                # Extract the non-dominated solutions (Pareto front)
                                                                                                                                                                                                                pareto_front = tools.sortNondominated(pop, k=len(pop), first_front_only=True)[0]

                                                                                                                                                                                                                # Sort the Pareto front by the first objective (Total Cost)
                                                                                                                                                                                                                sorted_front = sorted(pareto_front, key=lambda x: x.fitness.values[0])

                                                                                                                                                                                                                # Display the objective values for each solution on the Pareto front
                                                                                                                                                                                                                print("\nPareto Front Solutions (Objectives: Total Cost, " + ", ".join(traci_impact_cols) + "):")
                                                                                                                                                                                                                for i, ind in enumerate(sorted_front):
                                                                                                                                                                                                                    objective_values = ind.fitness.values
                                                                                                                                                                                                                    print(f"Solution {i+1}: Cost: {objective_values[0]:.2f}", end="")
                                                                                                                                                                                                                    for j, impact_value in enumerate(objective_values[1:]):
                                                                                                                                                                                                                        print(f", {traci_impact_cols[j]}: {impact_value:.4f}", end="")
                                                                                                                                                                                                                        print() # Newline after each solution

                                                                                                                                                                                                                        """## Summary:

                                                                                                                                                                                                                        ### Data Analysis Key Findings

                                                                                                                                                                                                                        *   The NSGA-II algorithm was successfully implemented to optimize material inputs, considering both total material cost and multiple TRACI impact categories simultaneously.
                                                                                                                                                                                                                        *   The optimization identified a set of non-dominated solutions (Pareto front) representing various trade-offs between minimizing cost and minimizing each of the nine TRACI environmental impacts.
                                                                                                                                                                                                                        *   As shown in the output, solutions on the Pareto front demonstrate the expected multi-objective trade-off: solutions with lower total costs generally exhibit higher values across the TRACI impact categories, and conversely, solutions with lower environmental impacts tend to have higher total costs. For example, Solution 1 has a cost of \$545.44 but relatively high impact values (e.g., 'kg CO2-Eq/Unit': 1132.0920), while Solution 15 has a much higher cost of \$686.39 but significantly lower impact values (e.g., 'kg CO2-Eq/Unit': 976.0590).

                                                                                                                                                                                                                        ### Insights or Next Steps

                                                                                                                                                                                                                        *   Due to the high dimensionality (10 objectives), a simple 2D scatter plot cannot fully represent the Pareto front. Further analysis or visualization techniques (e.g., parallel coordinate plots, radar charts) could be used to better understand the relationships and trade-offs among all ten objectives across the Pareto front solutions.
                                                                                                                                                                                                                        *   The solutions on the Pareto front represent optimal material input combinations under the given constraints (+/- 20% of base amounts). Decision-makers can choose a solution from this front based on their specific priorities regarding cost versus environmental impact.

                                                                                                                                                                                                                        # Task
                                                                                                                                                                                                                        Optimize material inputs within a +/- 20% range to find 1 optimal solution minimizing a combined objective of Total Cost plus the sum of all TRACI Impacts, and 1 optimal solution for each individual TRACI impact category (9 total) minimizing that specific impact. Highlight the Total Cost and Global Warming Potential (GWP) for each of these optimal solutions.

                                                                                                                                                                                                                        ## Define combined impact objective

                                                                                                                                                                                                                        ### Subtask:
                                                                                                                                                                                                                        Create a new objective function that calculates the sum of all TRACI impact categories for a given set of material inputs.

                                                                                                                                                                                                                        **Reasoning**:
                                                                                                                                                                                                                        Define the `evaluate_combined_impact` function to calculate the sum of all TRACI impacts.
                                                                                                                                                                                                                        """

                                                                                                                                                                                                                        def evaluate_combined_impact(individual):
                                                                                                                                                                                                                            """
                                                                                                                                                                                                                            Calculates the sum of all TRACI impact categories for a given set of material inputs.

                                                                                                                                                                                                                            Args:
                                                                                                                                                                                                                            individual: A list or array of material amounts.

                                                                                                                                                                                                                            Returns:
                                                                                                                                                                                                                            The total combined TRACI impact.
                                                                                                                                                                                                                            """
                                                                                                                                                                                                                            # Ensure non-negativity of individual values before calculation
                                                                                                                                                                                                                            adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                                                                            # Calculate total impact for each TRACI impact category
                                                                                                                                                                                                                            total_impacts = []
                                                                                                                                                                                                                            for i in range(impact_matrix.shape[1]): # Iterate based on the actual shape of impact_matrix
                                                                                                                                                                                                                                total_impact = np.dot(adjusted_amounts, impact_matrix[:, i])
                                                                                                                                                                                                                                total_impacts.append(total_impact)

                                                                                                                                                                                                                                # Sum all the calculated total impacts
                                                                                                                                                                                                                                combined_impact = sum(total_impacts)

                                                                                                                                                                                                                                return combined_impact

                                                                                                                                                                                                                                """## Optimize cost vs. combined impact

                                                                                                                                                                                                                                ### Subtask:
                                                                                                                                                                                                                                Perform a single-objective optimization to find the set of material inputs (within +/- 20% bounds) that minimizes a combined objective of Total Cost plus the sum of all TRACI Impacts.

                                                                                                                                                                                                                                **Reasoning**:
                                                                                                                                                                                                                                Define the new single-objective evaluation function, redefine the creator classes for single-objective minimization, register the evaluation function, initialize a new population, and run the single-objective optimization algorithm.
                                                                                                                                                                                                                                """

                                                                                                                                                                                                                                # 1. Define the new evaluation function for combined cost and impact
                                                                                                                                                                                                                                def evaluate_cost_combined(individual):
                                                                                                                                                                                                                                    """
                                                                                                                                                                                                                                    Evaluates an individual based on the sum of its total cost and combined TRACI impact.
                                                                                                                                                                                                                                    """
                                                                                                                                                                                                                                    # Ensure non-negativity of individual values
                                                                                                                                                                                                                                    adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                                                                                    # Calculate total cost
                                                                                                                                                                                                                                    total_cost = np.dot(adjusted_amounts, costs)

                                                                                                                                                                                                                                    # Calculate combined TRACI impact using the previously defined function
                                                                                                                                                                                                                                    combined_traci_impact = evaluate_combined_impact(adjusted_amounts)

                                                                                                                                                                                                                                    # Return the single objective value (sum of cost and combined impact)
                                                                                                                                                                                                                                    return (total_cost + combined_traci_impact,) # Return as a tuple for DEAP

                                                                                                                                                                                                                                    # 2. Re-create the creator.FitnessMin class for single-objective minimization
                                                                                                                                                                                                                                    # 3. Re-create the creator.Individual class
                                                                                                                                                                                                                                    try:
                                                                                                                                                                                                                                        del creator.FitnessMin
                                                                                                                                                                                                                                        except AttributeError:
                                                                                                                                                                                                                                            pass
                                                                                                                                                                                                                                            try:
                                                                                                                                                                                                                                                del creator.Individual
                                                                                                                                                                                                                                                except AttributeError:
                                                                                                                                                                                                                                                    pass

                                                                                                                                                                                                                                                    # Create Fitness class with a single objective to minimize
                                                                                                                                                                                                                                                    creator.create("FitnessMin", base.Fitness, weights=(-1.0,)) # Single weight for minimization

                                                                                                                                                                                                                                                    # Create Individual class
                                                                                                                                                                                                                                                    creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                                                                                                                                                                    # 4. Register the evaluate_cost_combined function with the toolbox
                                                                                                                                                                                                                                                    toolbox.register("evaluate", evaluate_cost_combined)

                                                                                                                                                                                                                                                    # 5. Initialize a new population using the updated Individual class
                                                                                                                                                                                                                                                    pop_single_obj = toolbox.population(n=POP_SIZE)

                                                                                                                                                                                                                                                    # Evaluate the initial population for the single objective
                                                                                                                                                                                                                                                    fitnesses_single_obj = list(map(toolbox.evaluate, pop_single_obj))
                                                                                                                                                                                                                                                    for ind, fit in zip(pop_single_obj, fitnesses_single_obj):
                                                                                                                                                                                                                                                        ind.fitness.values = fit

                                                                                                                                                                                                                                                        # 6. Run a single-objective optimization algorithm (eaSimple)
                                                                                                                                                                                                                                                        # The 'halloffame' will store the best individual found during the evolution
                                                                                                                                                                                                                                                        hof = tools.HallOfFame(1)

                                                                                                                                                                                                                                                        # Use eaSimple for single-objective optimization
                                                                                                                                                                                                                                                        algorithms.eaSimple(pop_single_obj, toolbox, cxpb=CXPB, mutpb=MUTPB, ngen=NGEN, halloffame=hof, verbose=True)

                                                                                                                                                                                                                                                        # 7. Store the best individual found by the optimization algorithm
                                                                                                                                                                                                                                                        best_individual_combined = hof[0]

                                                                                                                                                                                                                                                        """**Reasoning**:
                                                                                                                                                                                                                                                        The assertion error "Assigned values have not the same length than fitness weights" indicates that the `evaluate_cost_combined` function is not returning a tuple with the correct number of elements as defined by `creator.FitnessMin`. I have defined `FitnessMin` with a single weight (-1.0), so the evaluation function must return a tuple with exactly one element. The traceback shows the error occurs when assigning `ind.fitness.values = fit`, where `fit` is the output of `toolbox.evaluate`. I need to ensure `evaluate_cost_combined` correctly returns a tuple with a single value. I suspect the previous definition of `evaluate_cost_combined` might have been overwritten or the issue is with how `evaluate_combined_impact` is used. I will redefine the evaluation function explicitly within this step to ensure it returns a single-element tuple.


                                                                                                                                                                                                                                                        """

                                                                                                                                                                                                                                                        # Define the new evaluation function for combined cost and impact explicitly
                                                                                                                                                                                                                                                        def evaluate_cost_combined(individual):
                                                                                                                                                                                                                                                            """
                                                                                                                                                                                                                                                            Evaluates an individual based on the sum of its total cost and combined TRACI impact.
                                                                                                                                                                                                                                                            """
                                                                                                                                                                                                                                                            # Ensure non-negativity of individual values
                                                                                                                                                                                                                                                            adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                                                                                                            # Calculate total cost
                                                                                                                                                                                                                                                            total_cost = np.dot(adjusted_amounts, costs)

                                                                                                                                                                                                                                                            # Calculate combined TRACI impact
                                                                                                                                                                                                                                                            combined_traci_impact_value = 0.0
                                                                                                                                                                                                                                                            for i in range(impact_matrix.shape[1]): # Iterate based on the actual shape of impact_matrix
                                                                                                                                                                                                                                                                total_impact = np.dot(adjusted_amounts, impact_matrix[:, i])
                                                                                                                                                                                                                                                                combined_traci_impact_value += total_impact

                                                                                                                                                                                                                                                                # Return the single objective value (sum of cost and combined impact) as a tuple
                                                                                                                                                                                                                                                                return (total_cost + combined_traci_impact_value,)

                                                                                                                                                                                                                                                                # Re-create the creator.FitnessMin class for single-objective minimization
                                                                                                                                                                                                                                                                # Re-create the creator.Individual class
                                                                                                                                                                                                                                                                try:
                                                                                                                                                                                                                                                                    del creator.FitnessMin
                                                                                                                                                                                                                                                                    except AttributeError:
                                                                                                                                                                                                                                                                        pass
                                                                                                                                                                                                                                                                        try:
                                                                                                                                                                                                                                                                            del creator.Individual
                                                                                                                                                                                                                                                                            except AttributeError:
                                                                                                                                                                                                                                                                                pass

                                                                                                                                                                                                                                                                                # Create Fitness class with a single objective to minimize
                                                                                                                                                                                                                                                                                creator.create("FitnessMin", base.Fitness, weights=(-1.0,)) # Single weight for minimization

                                                                                                                                                                                                                                                                                # Create Individual class
                                                                                                                                                                                                                                                                                creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                                                                                                                                                                                                # Register the evaluate_cost_combined function with the toolbox
                                                                                                                                                                                                                                                                                toolbox.register("evaluate", evaluate_cost_combined)

                                                                                                                                                                                                                                                                                # Initialize a new population using the updated Individual class
                                                                                                                                                                                                                                                                                pop_single_obj = toolbox.population(n=POP_SIZE)

                                                                                                                                                                                                                                                                                # Evaluate the initial population for the single objective
                                                                                                                                                                                                                                                                                fitnesses_single_obj = list(map(toolbox.evaluate, pop_single_obj))
                                                                                                                                                                                                                                                                                for ind, fit in zip(pop_single_obj, fitnesses_single_obj):
                                                                                                                                                                                                                                                                                    ind.fitness.values = fit

                                                                                                                                                                                                                                                                                    # Run a single-objective optimization algorithm (eaSimple)
                                                                                                                                                                                                                                                                                    # The 'halloffame' will store the best individual found during the evolution
                                                                                                                                                                                                                                                                                    hof = tools.HallOfFame(1)

                                                                                                                                                                                                                                                                                    # Use eaSimple for single-objective optimization
                                                                                                                                                                                                                                                                                    algorithms.eaSimple(pop_single_obj, toolbox, cxpb=CXPB, mutpb=MUTPB, ngen=NGEN, halloffame=hof, verbose=True)

                                                                                                                                                                                                                                                                                    # Store the best individual found by the optimization algorithm
                                                                                                                                                                                                                                                                                    best_individual_combined = hof[0]

                                                                                                                                                                                                                                                                                    """**Reasoning**:
                                                                                                                                                                                                                                                                                    The "AssertionError: Assigned values have not the same length than fitness weights" persists, indicating the `evaluate_cost_combined` function is still not returning a tuple with a single element, despite my attempt to explicitly sum the impacts and return a single value tuple. This is unexpected, as the code explicitly calculates `total_cost + combined_traci_impact_value` and wraps it in `(...,)`. I will try re-running the exact same code block again. This might resolve transient issues or confirm if the problem lies elsewhere in the environment or previous cell states affecting the `toolbox` or `creator` definitions.


                                                                                                                                                                                                                                                                                    """

                                                                                                                                                                                                                                                                                    # Define the new evaluation function for combined cost and impact explicitly
                                                                                                                                                                                                                                                                                    def evaluate_cost_combined(individual):
                                                                                                                                                                                                                                                                                        """
                                                                                                                                                                                                                                                                                        Evaluates an individual based on the sum of its total cost and combined TRACI impact.
                                                                                                                                                                                                                                                                                        """
                                                                                                                                                                                                                                                                                        # Ensure non-negativity of individual values
                                                                                                                                                                                                                                                                                        adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                                                                                                                                        # Calculate total cost
                                                                                                                                                                                                                                                                                        total_cost = np.dot(adjusted_amounts, costs)

                                                                                                                                                                                                                                                                                        # Calculate combined TRACI impact
                                                                                                                                                                                                                                                                                        combined_traci_impact_value = 0.0
                                                                                                                                                                                                                                                                                        for i in range(impact_matrix.shape[1]): # Iterate based on the actual shape of impact_matrix
                                                                                                                                                                                                                                                                                            total_impact = np.dot(adjusted_amounts, impact_matrix[:, i])
                                                                                                                                                                                                                                                                                            combined_traci_impact_value += total_impact

                                                                                                                                                                                                                                                                                            # Return the single objective value (sum of cost and combined impact) as a tuple
                                                                                                                                                                                                                                                                                            return (total_cost + combined_traci_impact_value,)

                                                                                                                                                                                                                                                                                            # Re-create the creator.FitnessMin class for single-objective minimization
                                                                                                                                                                                                                                                                                            # Re-create the creator.Individual class
                                                                                                                                                                                                                                                                                            try:
                                                                                                                                                                                                                                                                                                del creator.FitnessMin
                                                                                                                                                                                                                                                                                                except AttributeError:
                                                                                                                                                                                                                                                                                                    pass
                                                                                                                                                                                                                                                                                                    try:
                                                                                                                                                                                                                                                                                                        del creator.Individual
                                                                                                                                                                                                                                                                                                        except AttributeError:
                                                                                                                                                                                                                                                                                                            pass

                                                                                                                                                                                                                                                                                                            # Create Fitness class with a single objective to minimize
                                                                                                                                                                                                                                                                                                            creator.create("FitnessMin", base.Fitness, weights=(-1.0,)) # Single weight for minimization

                                                                                                                                                                                                                                                                                                            # Create Individual class
                                                                                                                                                                                                                                                                                                            creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                                                                                                                                                                                                                            # Register the evaluate_cost_combined function with the toolbox
                                                                                                                                                                                                                                                                                                            toolbox.register("evaluate", evaluate_cost_combined)

                                                                                                                                                                                                                                                                                                            # Initialize a new population using the updated Individual class
                                                                                                                                                                                                                                                                                                            pop_single_obj = toolbox.population(n=POP_SIZE)

                                                                                                                                                                                                                                                                                                            # Evaluate the initial population for the single objective
                                                                                                                                                                                                                                                                                                            fitnesses_single_obj = list(map(toolbox.evaluate, pop_single_obj))
                                                                                                                                                                                                                                                                                                            for ind, fit in zip(pop_single_obj, fitnesses_single_obj):
                                                                                                                                                                                                                                                                                                                ind.fitness.values = fit

                                                                                                                                                                                                                                                                                                                # Run a single-objective optimization algorithm (eaSimple)
                                                                                                                                                                                                                                                                                                                # The 'halloffame' will store the best individual found during the evolution
                                                                                                                                                                                                                                                                                                                hof = tools.HallOfFame(1)

                                                                                                                                                                                                                                                                                                                # Use eaSimple for single-objective optimization
                                                                                                                                                                                                                                                                                                                algorithms.eaSimple(pop_single_obj, toolbox, cxpb=CXPB, mutpb=MUTPB, ngen=NGEN, halloffame=hof, verbose=True)

                                                                                                                                                                                                                                                                                                                # Store the best individual found by the optimization algorithm
                                                                                                                                                                                                                                                                                                                best_individual_combined = hof[0]

                                                                                                                                                                                                                                                                                                                """**Reasoning**:
                                                                                                                                                                                                                                                                                                                The "AssertionError: Assigned values have not the same length than fitness weights" continues to occur even after explicitly defining the evaluation function to return a single value and re-creating the `FitnessMin` class with a single weight. This suggests a potential issue with the DEAP toolbox or creator state being affected by previous multi-objective definitions or some other subtle interaction in the notebook environment. To try and isolate the issue and ensure a clean state for single-objective optimization, I will redefine the toolbox, creator classes, and evaluation function *all within a single code block* before running the `eaSimple` algorithm. This ensures that the single-objective setup is self-contained and not influenced by previous multi-objective configurations.


                                                                                                                                                                                                                                                                                                                """

                                                                                                                                                                                                                                                                                                                import numpy as np
                                                                                                                                                                                                                                                                                                                from deap import base, creator, tools, algorithms
                                                                                                                                                                                                                                                                                                                import random

                                                                                                                                                                                                                                                                                                                # Ensure random seed is set for reproducibility
                                                                                                                                                                                                                                                                                                                random.seed(42)

                                                                                                                                                                                                                                                                                                                # === Prepare Data for Optimization (Ensure alignment) ===
                                                                                                                                                                                                                                                                                                                # Re-extract costs and impact_matrix from merged_df to ensure alignment
                                                                                                                                                                                                                                                                                                                # This is important to ensure consistency with the evaluation function
                                                                                                                                                                                                                                                                                                                materials = merged_df['Material'].tolist()
                                                                                                                                                                                                                                                                                                                base_amounts = merged_df['Amount'].values
                                                                                                                                                                                                                                                                                                                costs = merged_df['Unit Cost ($)'].values

                                                                                                                                                                                                                                                                                                                # Define impact columns based *only* on columns present in merged_df that are from impact_df
                                                                                                                                                                                                                                                                                                                impact_columns = [col for col in impact_df.columns if col in merged_df.columns and col not in ['Material', 'Unit']]
                                                                                                                                                                                                                                                                                                                impact_matrix = merged_df[impact_columns].values

                                                                                                                                                                                                                                                                                                                # Redefine traci_impact_cols to match the actual impact columns used
                                                                                                                                                                                                                                                                                                                traci_impact_cols = impact_columns


                                                                                                                                                                                                                                                                                                                # === Single-Objective NSGA-II Setup (Re-initialize everything) ===
                                                                                                                                                                                                                                                                                                                # Attempt to delete previously created classes to avoid RuntimeWarning
                                                                                                                                                                                                                                                                                                                try:
                                                                                                                                                                                                                                                                                                                    del creator.FitnessMin
                                                                                                                                                                                                                                                                                                                    except AttributeError:
                                                                                                                                                                                                                                                                                                                        pass
                                                                                                                                                                                                                                                                                                                        try:
                                                                                                                                                                                                                                                                                                                            del creator.Individual
                                                                                                                                                                                                                                                                                                                            except AttributeError:
                                                                                                                                                                                                                                                                                                                                pass

                                                                                                                                                                                                                                                                                                                                # Create Fitness class with a single objective to minimize
                                                                                                                                                                                                                                                                                                                                creator.create("FitnessMin", base.Fitness, weights=(-1.0,)) # Single weight for minimization

                                                                                                                                                                                                                                                                                                                                # Create Individual class
                                                                                                                                                                                                                                                                                                                                creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                                                                                                                                                                                                                                                # Re-initialize toolbox
                                                                                                                                                                                                                                                                                                                                toolbox = base.Toolbox()

                                                                                                                                                                                                                                                                                                                                # Sensitivity bounds: +/- 20% of base amount
                                                                                                                                                                                                                                                                                                                                low_bounds = base_amounts * 0.8
                                                                                                                                                                                                                                                                                                                                high_bounds = base_amounts * 1.2

                                                                                                                                                                                                                                                                                                                                # Ensure lower bound is not negative
                                                                                                                                                                                                                                                                                                                                low_bounds[low_bounds < 0] = 0

                                                                                                                                                                                                                                                                                                                                # Attribute generator: random value within bounds, ensuring non-negativity
                                                                                                                                                                                                                                                                                                                                def create_ind():
                                                                                                                                                                                                                                                                                                                                    return [random.uniform(low, high) for low, high in zip(low_bounds, high_bounds)]

                                                                                                                                                                                                                                                                                                                                    toolbox.register("individual", tools.initIterate, creator.Individual, create_ind)
                                                                                                                                                                                                                                                                                                                                    toolbox.register("population", tools.initRepeat, list, toolbox.individual)

                                                                                                                                                                                                                                                                                                                                    # Define the new evaluation function for combined cost and impact explicitly
                                                                                                                                                                                                                                                                                                                                    def evaluate_cost_combined(individual):
                                                                                                                                                                                                                                                                                                                                        """
                                                                                                                                                                                                                                                                                                                                        Evaluates an individual based on the sum of its total cost and combined TRACI impact.
                                                                                                                                                                                                                                                                                                                                        """
                                                                                                                                                                                                                                                                                                                                        # Ensure non-negativity of individual values
                                                                                                                                                                                                                                                                                                                                        adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                                                                                                                                                                                        # Calculate total cost
                                                                                                                                                                                                                                                                                                                                        total_cost = np.dot(adjusted_amounts, costs)

                                                                                                                                                                                                                                                                                                                                        # Calculate combined TRACI impact
                                                                                                                                                                                                                                                                                                                                        combined_traci_impact_value = 0.0
                                                                                                                                                                                                                                                                                                                                        for i in range(impact_matrix.shape[1]): # Iterate based on the actual shape of impact_matrix
                                                                                                                                                                                                                                                                                                                                            total_impact = np.dot(adjusted_amounts, impact_matrix[:, i])
                                                                                                                                                                                                                                                                                                                                            combined_traci_impact_value += total_impact

                                                                                                                                                                                                                                                                                                                                            # Return the single objective value (sum of cost and combined impact) as a tuple
                                                                                                                                                                                                                                                                                                                                            return (total_cost + combined_traci_impact_value,)

                                                                                                                                                                                                                                                                                                                                            # Register the evaluate_cost_combined function with the toolbox
                                                                                                                                                                                                                                                                                                                                            toolbox.register("evaluate", evaluate_cost_combined)

                                                                                                                                                                                                                                                                                                                                            # Register crossover and mutation operators (assuming custom_crossover and custom_mutate are in scope)
                                                                                                                                                                                                                                                                                                                                            # If not, they would need to be defined here or imported.
                                                                                                                                                                                                                                                                                                                                            # Based on previous cells, custom_crossover and custom_mutate were used,
                                                                                                                                                                                                                                                                                                                                            # so let's assume they are in scope or use standard DEAP ones for this single-objective case.
                                                                                                                                                                                                                                                                                                                                            # Using standard ones is safer for a clean single-objective setup.
                                                                                                                                                                                                                                                                                                                                            toolbox.register("mate", tools.cxBlend, alpha=0.5)
                                                                                                                                                                                                                                                                                                                                            toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=0.1, indpb=0.2)
                                                                                                                                                                                                                                                                                                                                            toolbox.register("select", tools.selTournament, tournsize=3) # Using tournament selection for single-objective

                                                                                                                                                                                                                                                                                                                                            # === Run Single-Objective Optimization ===
                                                                                                                                                                                                                                                                                                                                            pop_single_obj = toolbox.population(n=POP_SIZE)

                                                                                                                                                                                                                                                                                                                                            # Evaluate the initial population for the single objective
                                                                                                                                                                                                                                                                                                                                            fitnesses_single_obj = list(map(toolbox.evaluate, pop_single_obj))
                                                                                                                                                                                                                                                                                                                                            for ind, fit in zip(pop_single_obj, fitnesses_single_obj):
                                                                                                                                                                                                                                                                                                                                                ind.fitness.values = fit

                                                                                                                                                                                                                                                                                                                                                # The 'halloffame' will store the best individual found during the evolution
                                                                                                                                                                                                                                                                                                                                                hof = tools.HallOfFame(1)

                                                                                                                                                                                                                                                                                                                                                # Use eaSimple for single-objective optimization
                                                                                                                                                                                                                                                                                                                                                algorithms.eaSimple(pop_single_obj, toolbox, cxpb=CXPB, mutpb=MUTPB, ngen=NGEN, halloffame=hof, verbose=True)

                                                                                                                                                                                                                                                                                                                                                # Store the best individual found by the optimization algorithm
                                                                                                                                                                                                                                                                                                                                                best_individual_combined = hof[0]

                                                                                                                                                                                                                                                                                                                                                # Display the best individual's fitness
                                                                                                                                                                                                                                                                                                                                                print("\nBest individual found (Total Cost + Combined TRACI Impact):")
                                                                                                                                                                                                                                                                                                                                                print(best_individual_combined.fitness.values)

                                                                                                                                                                                                                                                                                                                                                """## Optimize each individual impact

                                                                                                                                                                                                                                                                                                                                                ### Subtask:
                                                                                                                                                                                                                                                                                                                                                For each of the nine TRACI impact categories, perform a separate single-objective optimization to find the set of material inputs (within +/- 20% bounds) that minimizes that specific impact category.

                                                                                                                                                                                                                                                                                                                                                **Reasoning**:
                                                                                                                                                                                                                                                                                                                                                Iterate through each TRACI impact column, set up a single-objective optimization for each, run the optimization, and store the best result.
                                                                                                                                                                                                                                                                                                                                                """

                                                                                                                                                                                                                                                                                                                                                # Dictionary to store the best individual for each TRACI impact objective
                                                                                                                                                                                                                                                                                                                                                best_individuals_impact = {}

                                                                                                                                                                                                                                                                                                                                                # Iterate through each TRACI impact column
                                                                                                                                                                                                                                                                                                                                                for impact_col in traci_impact_cols:
                                                                                                                                                                                                                                                                                                                                                    print(f"\nOptimizing for: {impact_col}")

                                                                                                                                                                                                                                                                                                                                                    # Attempt to delete previously created classes to avoid RuntimeWarning
                                                                                                                                                                                                                                                                                                                                                    try:
                                                                                                                                                                                                                                                                                                                                                        del creator.FitnessMin
                                                                                                                                                                                                                                                                                                                                                        except AttributeError:
                                                                                                                                                                                                                                                                                                                                                            pass
                                                                                                                                                                                                                                                                                                                                                            try:
                                                                                                                                                                                                                                                                                                                                                                del creator.Individual
                                                                                                                                                                                                                                                                                                                                                                except AttributeError:
                                                                                                                                                                                                                                                                                                                                                                    pass

                                                                                                                                                                                                                                                                                                                                                                    # Create Fitness class with a single objective to minimize
                                                                                                                                                                                                                                                                                                                                                                    creator.create("FitnessMin", base.Fitness, weights=(-1.0,)) # Single weight for minimization

                                                                                                                                                                                                                                                                                                                                                                    # Create Individual class
                                                                                                                                                                                                                                                                                                                                                                    creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                                                                                                                                                                                                                                                                                    # Re-initialize toolbox for each single-objective optimization
                                                                                                                                                                                                                                                                                                                                                                    toolbox = base.Toolbox()

                                                                                                                                                                                                                                                                                                                                                                    # Sensitivity bounds: +/- 20% of base amount (ensure non-negativity)
                                                                                                                                                                                                                                                                                                                                                                    low_bounds = base_amounts * 0.8
                                                                                                                                                                                                                                                                                                                                                                    high_bounds = base_amounts * 1.2
                                                                                                                                                                                                                                                                                                                                                                    low_bounds[low_bounds < 0] = 0

                                                                                                                                                                                                                                                                                                                                                                    # Attribute generator: random value within bounds
                                                                                                                                                                                                                                                                                                                                                                    def create_ind():
                                                                                                                                                                                                                                                                                                                                                                        return [random.uniform(low, high) for low, high in zip(low_bounds, high_bounds)]

                                                                                                                                                                                                                                                                                                                                                                        toolbox.register("individual", tools.initIterate, creator.Individual, create_ind)
                                                                                                                                                                                                                                                                                                                                                                        toolbox.register("population", tools.initRepeat, list, toolbox.individual)

                                                                                                                                                                                                                                                                                                                                                                        # Define the evaluation function specifically for the current impact_col
                                                                                                                                                                                                                                                                                                                                                                        def evaluate_impact(individual):
                                                                                                                                                                                                                                                                                                                                                                            """
                                                                                                                                                                                                                                                                                                                                                                            Evaluates an individual based on a single TRACI impact category.
                                                                                                                                                                                                                                                                                                                                                                            """
                                                                                                                                                                                                                                                                                                                                                                            # Ensure non-negativity of individual values
                                                                                                                                                                                                                                                                                                                                                                            adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                                                                                                                                                                                                                            # Find the index for the current impact column
                                                                                                                                                                                                                                                                                                                                                                            try:
                                                                                                                                                                                                                                                                                                                                                                                impact_idx = traci_impact_cols.index(impact_col)
                                                                                                                                                                                                                                                                                                                                                                                total_impact = np.dot(adjusted_amounts, impact_matrix[:, impact_idx])
                                                                                                                                                                                                                                                                                                                                                                                except ValueError:
                                                                                                                                                                                                                                                                                                                                                                                    print(f"Warning: '{impact_col}' not found in impact columns. Impact will be 0.")
                                                                                                                                                                                                                                                                                                                                                                                    total_impact = 0.0

                                                                                                                                                                                                                                                                                                                                                                                    # Return the single objective value as a tuple
                                                                                                                                                                                                                                                                                                                                                                                    return (total_impact,)

                                                                                                                                                                                                                                                                                                                                                                                    # Register the evaluate_impact function with the toolbox
                                                                                                                                                                                                                                                                                                                                                                                    toolbox.register("evaluate", evaluate_impact)

                                                                                                                                                                                                                                                                                                                                                                                    # Register crossover and mutation operators
                                                                                                                                                                                                                                                                                                                                                                                    toolbox.register("mate", tools.cxBlend, alpha=0.5)
                                                                                                                                                                                                                                                                                                                                                                                    toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=0.1, indpb=0.2)
                                                                                                                                                                                                                                                                                                                                                                                    toolbox.register("select", tools.selTournament, tournsize=3) # Using tournament selection for single-objective

                                                                                                                                                                                                                                                                                                                                                                                    # === Run Single-Objective Optimization ===
                                                                                                                                                                                                                                                                                                                                                                                    pop_impact_obj = toolbox.population(n=POP_SIZE)

                                                                                                                                                                                                                                                                                                                                                                                    # Evaluate the initial population
                                                                                                                                                                                                                                                                                                                                                                                    fitnesses_impact_obj = list(map(toolbox.evaluate, pop_impact_obj))
                                                                                                                                                                                                                                                                                                                                                                                    for ind, fit in zip(pop_impact_obj, fitnesses_impact_obj):
                                                                                                                                                                                                                                                                                                                                                                                        ind.fitness.values = fit

                                                                                                                                                                                                                                                                                                                                                                                        # The 'halloffame' will store the best individual found
                                                                                                                                                                                                                                                                                                                                                                                        hof = tools.HallOfFame(1)

                                                                                                                                                                                                                                                                                                                                                                                        # Use eaSimple for single-objective optimization
                                                                                                                                                                                                                                                                                                                                                                                        algorithms.eaSimple(pop_impact_obj, toolbox, cxpb=CXPB, mutpb=MUTPB, ngen=NGEN, halloffame=hof, verbose=False)

                                                                                                                                                                                                                                                                                                                                                                                        # Store the best individual found
                                                                                                                                                                                                                                                                                                                                                                                        best_individuals_impact[impact_col] = hof[0]

                                                                                                                                                                                                                                                                                                                                                                                        # Print the best individual's fitness for this impact category
                                                                                                                                                                                                                                                                                                                                                                                        print(f"Optimization for {impact_col} completed. Best fitness: {hof[0].fitness.values}")

                                                                                                                                                                                                                                                                                                                                                                                        """**Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                        Display the total cost and GWP for each of the optimal solutions found for each individual TRACI impact category.


                                                                                                                                                                                                                                                                                                                                                                                        """

                                                                                                                                                                                                                                                                                                                                                                                        # Calculate and display Total Cost and GWP for each best individual found for each impact category
                                                                                                                                                                                                                                                                                                                                                                                        print("\nTotal Cost and GWP for Optimal Solution of Each TRACI Impact:")

                                                                                                                                                                                                                                                                                                                                                                                        # Redefine the evaluate function to return all objective values (Cost + all Impacts)
                                                                                                                                                                                                                                                                                                                                                                                        # This is needed to calculate the Cost and GWP for the single-objective optimal individuals
                                                                                                                                                                                                                                                                                                                                                                                        def evaluate_all_objectives(individual):
                                                                                                                                                                                                                                                                                                                                                                                            """
                                                                                                                                                                                                                                                                                                                                                                                            Evaluates an individual based on Total Cost and all TRACI impact categories.
                                                                                                                                                                                                                                                                                                                                                                                            Returns a tuple of (Total Cost, Impact 1, Impact 2, ...).
                                                                                                                                                                                                                                                                                                                                                                                            """
                                                                                                                                                                                                                                                                                                                                                                                            adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                                                                                                                                                                                                                                            total_cost = np.dot(adjusted_amounts, costs)

                                                                                                                                                                                                                                                                                                                                                                                            total_impacts = []
                                                                                                                                                                                                                                                                                                                                                                                            for i in range(impact_matrix.shape[1]):
                                                                                                                                                                                                                                                                                                                                                                                                total_impact = np.dot(adjusted_amounts, impact_matrix[:, i])
                                                                                                                                                                                                                                                                                                                                                                                                total_impacts.append(total_impact)

                                                                                                                                                                                                                                                                                                                                                                                                return (total_cost,) + tuple(total_impacts)

                                                                                                                                                                                                                                                                                                                                                                                                # Find the index for the GWP column ('kg CO2-Eq/Unit')
                                                                                                                                                                                                                                                                                                                                                                                                try:
                                                                                                                                                                                                                                                                                                                                                                                                    gwp_idx_for_display = traci_impact_cols.index("kg CO2-Eq/Unit")
                                                                                                                                                                                                                                                                                                                                                                                                    except ValueError:
                                                                                                                                                                                                                                                                                                                                                                                                        gwp_idx_for_display = -1 # Indicates GWP column not found

                                                                                                                                                                                                                                                                                                                                                                                                        for impact_col, best_individual in best_individuals_impact.items():
                                                                                                                                                                                                                                                                                                                                                                                                            # Evaluate the best individual using the function that returns all objectives
                                                                                                                                                                                                                                                                                                                                                                                                            all_objective_values = evaluate_all_objectives(best_individual)

                                                                                                                                                                                                                                                                                                                                                                                                            # Extract Total Cost (first objective)
                                                                                                                                                                                                                                                                                                                                                                                                            total_cost = all_objective_values[0]

                                                                                                                                                                                                                                                                                                                                                                                                            # Extract GWP (using the determined index)
                                                                                                                                                                                                                                                                                                                                                                                                            if gwp_idx_for_display != -1:
                                                                                                                                                                                                                                                                                                                                                                                                                # GWP is at index gwp_idx_for_display in traci_impact_cols,
                                                                                                                                                                                                                                                                                                                                                                                                                # which corresponds to index gwp_idx_for_display + 1 in all_objective_values
                                                                                                                                                                                                                                                                                                                                                                                                                total_gwp = all_objective_values[gwp_idx_for_display + 1]
                                                                                                                                                                                                                                                                                                                                                                                                                else:
                                                                                                                                                                                                                                                                                                                                                                                                                    total_gwp = "N/A (GWP column not found)"

                                                                                                                                                                                                                                                                                                                                                                                                                    # Find the index for the currently minimized impact column
                                                                                                                                                                                                                                                                                                                                                                                                                    try:
                                                                                                                                                                                                                                                                                                                                                                                                                        minimized_impact_idx = traci_impact_cols.index(impact_col)
                                                                                                                                                                                                                                                                                                                                                                                                                        minimized_impact_value = all_objective_values[minimized_impact_idx + 1] # +1 because cost is the first objective
                                                                                                                                                                                                                                                                                                                                                                                                                        except ValueError:
                                                                                                                                                                                                                                                                                                                                                                                                                            minimized_impact_value = "N/A (Impact column not found)"


                                                                                                                                                                                                                                                                                                                                                                                                                            print(f"Optimal solution for {impact_col}:")
                                                                                                                                                                                                                                                                                                                                                                                                                            print(f"  Total Cost: {total_cost:.2f}")
                                                                                                                                                                                                                                                                                                                                                                                                                            print(f"  Total GWP: {total_gwp:.4f}" if isinstance(total_gwp, float) else f"  Total GWP: {total_gwp}")
                                                                                                                                                                                                                                                                                                                                                                                                                            print(f"  Minimized {impact_col}: {minimized_impact_value:.4f}" if isinstance(minimized_impact_value, float) else f"  Minimized {impact_col}: {minimized_impact_value}")
                                                                                                                                                                                                                                                                                                                                                                                                                            print("-" * 30)

                                                                                                                                                                                                                                                                                                                                                                                                                            # Also display the combined objective solution with its objectives
                                                                                                                                                                                                                                                                                                                                                                                                                            if 'best_individual_combined' in locals():
                                                                                                                                                                                                                                                                                                                                                                                                                                print("\nOptimal solution for Total Cost + Combined TRACI Impact:")
                                                                                                                                                                                                                                                                                                                                                                                                                                combined_solution_objectives = evaluate_all_objectives(best_individual_combined)
                                                                                                                                                                                                                                                                                                                                                                                                                                total_cost_combined = combined_solution_objectives[0]
                                                                                                                                                                                                                                                                                                                                                                                                                                if gwp_idx_for_display != -1:
                                                                                                                                                                                                                                                                                                                                                                                                                                    total_gwp_combined = combined_solution_objectives[gwp_idx_for_display + 1]
                                                                                                                                                                                                                                                                                                                                                                                                                                    else:
                                                                                                                                                                                                                                                                                                                                                                                                                                        total_gwp_combined = "N/A (GWP column not found)"

                                                                                                                                                                                                                                                                                                                                                                                                                                        # Calculate the combined impact value for display
                                                                                                                                                                                                                                                                                                                                                                                                                                        combined_impact_value = sum(combined_solution_objectives[1:])

                                                                                                                                                                                                                                                                                                                                                                                                                                        print(f"  Total Cost: {total_cost_combined:.2f}")
                                                                                                                                                                                                                                                                                                                                                                                                                                        print(f"  Total GWP: {total_gwp_combined:.4f}" if isinstance(total_gwp_combined, float) else f"  Total GWP: {total_gwp_combined}")
                                                                                                                                                                                                                                                                                                                                                                                                                                        print(f"  Total Combined TRACI Impact: {combined_impact_value:.4f}")
                                                                                                                                                                                                                                                                                                                                                                                                                                        print("-" * 30)

                                                                                                                                                                                                                                                                                                                                                                                                                                        """## Collect optimal solutions

                                                                                                                                                                                                                                                                                                                                                                                                                                        ### Subtask:
                                                                                                                                                                                                                                                                                                                                                                                                                                        Gather the optimal material inputs and their corresponding Total Cost and values for all nine TRACI impact categories from all the single-objective optimization runs (Cost + Combined Impact, and each of the 9 individual impacts).

                                                                                                                                                                                                                                                                                                                                                                                                                                        **Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                        Create an empty dictionary to store the results. Add the optimal solution for minimizing Total Cost + Combined TRACI Impact, calculate its objectives using `evaluate_all_objectives`, and store the results. Iterate through the `best_individuals_impact` dictionary, calculate the objectives for each optimal individual using `evaluate_all_objectives`, and store the results, associating them with the corresponding impact category. Finally, structure the collected data into a list of dictionaries for easy access.
                                                                                                                                                                                                                                                                                                                                                                                                                                        """

                                                                                                                                                                                                                                                                                                                                                                                                                                        # Dictionary to store all collected optimal solutions and their objective values
                                                                                                                                                                                                                                                                                                                                                                                                                                        optimal_solutions_data = {}

                                                                                                                                                                                                                                                                                                                                                                                                                                        # 1. Add the optimal solution for minimizing Total Cost + Combined TRACI Impact
                                                                                                                                                                                                                                                                                                                                                                                                                                        if 'best_individual_combined' in locals():
                                                                                                                                                                                                                                                                                                                                                                                                                                            combined_solution_objectives = evaluate_all_objectives(best_individual_combined)
                                                                                                                                                                                                                                                                                                                                                                                                                                            optimal_solutions_data['Total Cost + Combined Impact'] = {
                                                                                                                                                                                                                                                                                                                                                                                                                                            'Material Inputs': best_individual_combined,
                                                                                                                                                                                                                                                                                                                                                                                                                                            'Objective Values': combined_solution_objectives
                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                            print("Collected data for: Total Cost + Combined Impact")
                                                                                                                                                                                                                                                                                                                                                                                                                                            else:
                                                                                                                                                                                                                                                                                                                                                                                                                                                print("Warning: 'best_individual_combined' not found. Skipping data collection for combined objective.")


                                                                                                                                                                                                                                                                                                                                                                                                                                                # 2. Iterate through best_individuals_impact and add data for each single-impact optimal solution
                                                                                                                                                                                                                                                                                                                                                                                                                                                if 'best_individuals_impact' in locals():
                                                                                                                                                                                                                                                                                                                                                                                                                                                    for impact_col, best_individual in best_individuals_impact.items():
                                                                                                                                                                                                                                                                                                                                                                                                                                                        single_impact_solution_objectives = evaluate_all_objectives(best_individual)
                                                                                                                                                                                                                                                                                                                                                                                                                                                        optimal_solutions_data[f'Minimize {impact_col}'] = {
                                                                                                                                                                                                                                                                                                                                                                                                                                                        'Material Inputs': best_individual,
                                                                                                                                                                                                                                                                                                                                                                                                                                                        'Objective Values': single_impact_solution_objectives
                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                        print(f"Collected data for: Minimize {impact_col}")
                                                                                                                                                                                                                                                                                                                                                                                                                                                        else:
                                                                                                                                                                                                                                                                                                                                                                                                                                                            print("Warning: 'best_individuals_impact' not found. Skipping data collection for single impact objectives.")

                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Structure the data into a list of dictionaries for easier access and potential DataFrame creation later
                                                                                                                                                                                                                                                                                                                                                                                                                                                            structured_optimal_solutions = []

                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Add combined objective data
                                                                                                                                                                                                                                                                                                                                                                                                                                                            if 'Total Cost + Combined Impact' in optimal_solutions_data:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                solution_data = optimal_solutions_data['Total Cost + Combined Impact']
                                                                                                                                                                                                                                                                                                                                                                                                                                                                solution_entry = {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                'Optimization Objective': 'Total Cost + Combined Impact',
                                                                                                                                                                                                                                                                                                                                                                                                                                                                'Material Inputs': solution_data['Material Inputs'],
                                                                                                                                                                                                                                                                                                                                                                                                                                                                'Total Cost ($)': solution_data['Objective Values'][0]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Add each TRACI impact value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                for j, impact_col in enumerate(traci_impact_cols):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    solution_entry[impact_col] = solution_data['Objective Values'][j + 1]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    structured_optimal_solutions.append(solution_entry)


                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Add single impact objective data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    for impact_col in traci_impact_cols:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        objective_key = f'Minimize {impact_col}'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if objective_key in optimal_solutions_data:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            solution_data = optimal_solutions_data[objective_key]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            solution_entry = {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            'Optimization Objective': objective_key,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            'Material Inputs': solution_data['Material Inputs'],
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            'Total Cost ($)': solution_data['Objective Values'][0]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Add each TRACI impact value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            for j, current_impact_col in enumerate(traci_impact_cols):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                solution_entry[current_impact_col] = solution_data['Objective Values'][j + 1]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                structured_optimal_solutions.append(solution_entry)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Display the collected data structure (optional, for verification)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # print("\nStructured Optimal Solutions Data:")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # display(structured_optimal_solutions) # Use display for notebook output

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """## Highlight cost vs. gwp

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ### Subtask:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                For the collected optimal solutions, specifically extract and present the Total Cost and the Global Warming Potential (GWP, 'kg CO2-Eq/Unit') values to show the trade-offs achieved by optimizing for different single objectives.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                **Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Iterate through the collected optimal solutions and print the optimization objective, Total Cost, and GWP for each.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print("\nSummary of Optimal Solutions (Cost and GWP):")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for solution_entry in structured_optimal_solutions:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    objective = solution_entry['Optimization Objective']
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    total_cost = solution_entry['Total Cost ($)']
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    total_gwp = solution_entry.get('kg CO2-Eq/Unit', 'N/A (GWP column not found)') # Use .get to handle cases where GWP might be missing

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print(f"Objective: {objective}")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print(f"  Total Cost: {total_cost:.2f}")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print(f"  Total GWP: {total_gwp:.4f}" if isinstance(total_gwp, float) else f"  Total GWP: {total_gwp}")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print("-" * 30)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """## Summary:

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ### Data Analysis Key Findings

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   A single-objective optimization was successfully performed to find the set of material inputs that minimizes the combined objective of Total Cost plus the sum of all TRACI Impacts.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   Separate single-objective optimizations were successfully performed for each of the nine individual TRACI impact categories to find the material inputs minimizing each specific impact.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   For the optimal solution minimizing the combined objective (Total Cost + Combined Impact), the Total Cost and Global Warming Potential (GWP) were calculated.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   For each of the nine optimal solutions minimizing an individual TRACI impact, the Total Cost and Global Warming Potential (GWP) were calculated and presented.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   The results highlight the trade-offs between minimizing Total Cost, minimizing combined environmental impact, and minimizing individual environmental impacts, showing that optimizing for one objective generally results in different values for other objectives.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ### Insights or Next Steps

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   The presented Total Cost and GWP values for each optimal solution provide a clear view of the trade-offs, allowing stakeholders to choose a solution based on their priorities (e.g., cost minimization vs. GWP reduction).
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   Further analysis could involve visualizing these trade-offs in a scatter plot (e.g., Total Cost vs. GWP) to better understand the solution space and the performance of each optimal solution relative to others.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Task
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Perform multi-objective optimization using NSGA-II to find the Pareto front for minimizing Total Cost and each individual TRACI impact category (GWP, ODP, AP, EP, POCP, CC, HTPc, HTPn, TETp) separately, allowing material inputs to vary by +/- 20%. For each optimization, report the Total Cost and the value for the specific TRACI impact category being minimized, in addition to the GWP. Highlight the results for the GWP vs. Cost optimization.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ## Identify impact objectives

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ### Subtask:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Determine all the TRACI impact columns in the `impact_df`.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    **Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Extract the column names from the impact_df DataFrame that are not 'Material' or 'Unit' and store them in a list to identify the TRACI impact categories.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    traci_impact_cols = [col for col in impact_df.columns if col not in ['Material', 'Unit']]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print("TRACI Impact Columns:")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print(traci_impact_cols)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """## Iterate through impact objectives

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ### Subtask:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Loop through each identified TRACI impact column.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    **Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Iterate through each TRACI impact column.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Initialize a dictionary to store Pareto fronts for each impact category
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    pareto_fronts_by_impact = {}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Loop through each identified TRACI impact column
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    for impact_col in traci_impact_cols:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        print(f"Processing optimization for impact: {impact_col}")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # === Ensure Data Alignment within the loop ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Re-extract costs and impact_matrix from merged_df to ensure alignment
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # This is crucial to ensure the evaluate function uses the correct arrays
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        materials = merged_df['Material'].tolist()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        base_amounts = merged_df['Amount'].values
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        costs = merged_df['Unit Cost ($)'].values

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Define impact columns based *only* on columns present in merged_df that are from impact_df
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # This ensures impact_matrix has the correct columns and rows
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        impact_columns = [col for col in impact_df.columns if col in merged_df.columns and col not in ['Material', 'Unit']]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        impact_matrix = merged_df[impact_columns].values

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # === NSGA-II Setup for Cost vs. Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Attempt to delete previously created classes to avoid RuntimeWarning
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        try:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            del creator.FitnessMin
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            except AttributeError:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                try:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    del creator.Individual
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    except AttributeError:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        pass

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Create Fitness class with two objectives to minimize (Cost and current Impact)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        creator.create("FitnessMin", base.Fitness, weights=(-1.0, -1.0))

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Create Individual class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Re-initialize toolbox for each optimization run to ensure a clean state
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        toolbox = base.Toolbox()

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Sensitivity bounds: +/- 20% of base amount (ensure non-negativity)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        low_bounds = base_amounts * 0.8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        high_bounds = base_amounts * 1.2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        low_bounds[low_bounds < 0] = 0

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Attribute generator: random value within bounds
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        def create_ind():
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            return [random.uniform(low, high) for low, high in zip(low_bounds, high_bounds)]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            toolbox.register("individual", tools.initIterate, creator.Individual, create_ind)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            toolbox.register("population", tools.initRepeat, list, toolbox.individual)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Define the evaluation function specifically for Cost and the current impact_col
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            def evaluate_cost_impact(individual):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Evaluates an individual based on Total Cost and a single TRACI impact category.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Ensure non-negativity of individual values
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Calculate total cost
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                total_cost = np.dot(adjusted_amounts, costs)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Find the index for the current impact column within the *current* impact_columns list
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                try:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    impact_idx = impact_columns.index(impact_col)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    total_impact = np.dot(adjusted_amounts, impact_matrix[:, impact_idx])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    except ValueError:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        print(f"Warning: '{impact_col}' not found in impact columns during evaluation. Impact will be 0.")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        total_impact = 0.0

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Return the two objective values as a tuple
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        return total_cost, total_impact

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Register the evaluate_cost_impact function with the toolbox
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        toolbox.register("evaluate", evaluate_cost_impact)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Register crossover and mutation operators (using standard DEAP ones for simplicity)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Assuming custom_crossover and custom_mutate are defined in r43WIBYbmPPy and in scope.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # If not, these would need to be defined or standard DEAP operators used.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Let's use standard DEAP operators for simplicity and to avoid dependency on previous custom definitions.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        toolbox.register("mate", tools.cxBlend, alpha=0.5)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Ensure mutation respects bounds and non-negativity
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        def bounded_gaussian_mutate(individual, mu, sigma, indpb, low_bounds, high_bounds):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            mutated_individual = tools.mutGaussian(individual, mu, sigma, indpb)[0]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            for i in range(len(mutated_individual)):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                mutated_individual[i] = max(low_bounds[i], min(high_bounds[i], mutated_individual[i]))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                return mutated_individual,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                toolbox.register("mutate", bounded_gaussian_mutate, mu=0, sigma=0.1, indpb=0.2, low_bounds=low_bounds, high_bounds=high_bounds)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                toolbox.register("select", tools.selNSGA2) # Use NSGA-II selection for multi-objective

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # === Run NSGA-II Optimization for Cost vs. Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                pop = toolbox.population(n=POP_SIZE)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Evaluate the initial population
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                fitnesses = list(map(toolbox.evaluate, pop))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for ind, fit in zip(pop, fitnesses):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ind.fitness.values = fit

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # This is the main NSGA-II algorithm
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    algorithms.eaMuPlusLambda(pop, toolbox, mu=POP_SIZE, lambda_=POP_SIZE,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    cxpb=CXPB, mutpb=MUTPB, ngen=NGEN, verbose=False) # Set verbose to False to reduce output

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # === Extract Pareto-Optimal Solutions for Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Get the first front (non-dominated solutions) for this optimization run
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    pareto_front_impact = tools.sortNondominated(pop, k=len(pop), first_front_only=True)[0]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Store the Pareto front for this impact in the dictionary
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    pareto_fronts_by_impact[impact_col] = pareto_front_impact

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """**Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Set up the NSGA-II optimization for the current TRACI impact objective. This involves defining the fitness function with two objectives (Total Cost and the current TRACI impact), creating the DEAP creator classes, registering the evaluation function with the toolbox, and initializing the population.


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # === NSGA-II Setup for Cost vs. Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Attempt to delete previously created classes to avoid RuntimeWarning
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    try:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        del creator.FitnessMin
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        except AttributeError:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            try:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                del creator.Individual
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                except AttributeError:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    pass

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Create Fitness class with two objectives to minimize (Cost and current Impact)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    creator.create("FitnessMin", base.Fitness, weights=(-1.0, -1.0))

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Create Individual class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Re-initialize toolbox for each optimization run to ensure a clean state
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    toolbox = base.Toolbox()

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Sensitivity bounds: +/- 20% of base amount (ensure non-negativity)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    low_bounds = base_amounts * 0.8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    high_bounds = base_amounts * 1.2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    low_bounds[low_bounds < 0] = 0

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Attribute generator: random value within bounds
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    def create_ind():
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        return [random.uniform(low, high) for low, high in zip(low_bounds, high_bounds)]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        toolbox.register("individual", tools.initIterate, creator.Individual, create_ind)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        toolbox.register("population", tools.initRepeat, list, toolbox.individual)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Define the evaluation function specifically for Cost and the current impact_col
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        def evaluate_cost_impact(individual):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Evaluates an individual based on Total Cost and a single TRACI impact category.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Ensure non-negativity of individual values
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Calculate total cost
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            total_cost = np.dot(adjusted_amounts, costs)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Find the index for the current impact column
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            try:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                impact_idx = traci_impact_cols.index(impact_col)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                total_impact = np.dot(adjusted_amounts, impact_matrix[:, impact_idx])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                except ValueError:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print(f"Warning: '{impact_col}' not found in impact columns during evaluation. Impact will be 0.")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    total_impact = 0.0

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Return the two objective values as a tuple
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    return total_cost, total_impact

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Register the evaluate_cost_impact function with the toolbox
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    toolbox.register("evaluate", evaluate_cost_impact)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Register crossover and mutation operators (using standard DEAP ones for simplicity)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    toolbox.register("mate", tools.cxBlend, alpha=0.5)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=0.1, indpb=0.2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    toolbox.register("select", tools.selNSGA2) # Use NSGA-II selection for multi-objective

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """**Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Run the NSGA-II optimization algorithm for the current TRACI impact objective using the setup defined in the previous step. After the optimization, extract the Pareto front solutions for this specific run.


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # === Run NSGA-II Optimization for Cost vs. Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    pop = toolbox.population(n=POP_SIZE)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Evaluate the initial population
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    fitnesses = list(map(toolbox.evaluate, pop))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    for ind, fit in zip(pop, fitnesses):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ind.fitness.values = fit

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # This is the main NSGA-II algorithm
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        algorithms.eaMuPlusLambda(pop, toolbox, mu=POP_SIZE, lambda_=POP_SIZE,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        cxpb=CXPB, mutpb=MUTPB, ngen=NGEN, verbose=False) # Set verbose to False to reduce output

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # === Extract Pareto-Optimal Solutions for Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Get the first front (non-dominated solutions) for this optimization run
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        pareto_front_impact = tools.sortNondominated(pop, k=len(pop), first_front_only=True)[0]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Store the Pareto front for this impact in a dictionary
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        pareto_fronts_by_impact[impact_col] = pareto_front_impact

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """**Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        The `NameError` indicates that the dictionary `pareto_fronts_by_impact` was used before it was defined. I need to initialize this dictionary before the loop that iterates through the impact columns to store the Pareto fronts for each impact category.


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Initialize a dictionary to store Pareto fronts for each impact category
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        pareto_fronts_by_impact = {}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Loop through each identified TRACI impact column
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for impact_col in traci_impact_cols:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            print(f"Processing optimization for impact: {impact_col}")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # === NSGA-II Setup for Cost vs. Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Attempt to delete previously created classes to avoid RuntimeWarning
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            try:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                del creator.FitnessMin
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                except AttributeError:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    try:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        del creator.Individual
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        except AttributeError:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            pass

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Create Fitness class with two objectives to minimize (Cost and current Impact)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            creator.create("FitnessMin", base.Fitness, weights=(-1.0, -1.0))

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Create Individual class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Re-initialize toolbox for each optimization run to ensure a clean state
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            toolbox = base.Toolbox()

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Sensitivity bounds: +/- 20% of base amount (ensure non-negativity)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            low_bounds = base_amounts * 0.8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            high_bounds = base_amounts * 1.2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            low_bounds[low_bounds < 0] = 0

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Attribute generator: random value within bounds
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            def create_ind():
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                return [random.uniform(low, high) for low, high in zip(low_bounds, high_bounds)]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                toolbox.register("individual", tools.initIterate, creator.Individual, create_ind)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                toolbox.register("population", tools.initRepeat, list, toolbox.individual)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Define the evaluation function specifically for Cost and the current impact_col
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                def evaluate_cost_impact(individual):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Evaluates an individual based on Total Cost and a single TRACI impact category.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Ensure non-negativity of individual values
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Calculate total cost
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    total_cost = np.dot(adjusted_amounts, costs)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Find the index for the current impact column
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    try:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        impact_idx = traci_impact_cols.index(impact_col)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        total_impact = np.dot(adjusted_amounts, impact_matrix[:, impact_idx])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        except ValueError:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            print(f"Warning: '{impact_col}' not found in impact columns during evaluation. Impact will be 0.")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            total_impact = 0.0

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Return the two objective values as a tuple
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            return total_cost, total_impact

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Register the evaluate_cost_impact function with the toolbox
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            toolbox.register("evaluate", evaluate_cost_impact)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Register crossover and mutation operators (using standard DEAP ones for simplicity)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            toolbox.register("mate", tools.cxBlend, alpha=0.5)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=0.1, indpb=0.2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            toolbox.register("select", tools.selNSGA2) # Use NSGA-II selection for multi-objective

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # === Run NSGA-II Optimization for Cost vs. Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            pop = toolbox.population(n=POP_SIZE)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Evaluate the initial population
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            fitnesses = list(map(toolbox.evaluate, pop))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            for ind, fit in zip(pop, fitnesses):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ind.fitness.values = fit

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # This is the main NSGA-II algorithm
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                algorithms.eaMuPlusLambda(pop, toolbox, mu=POP_SIZE, lambda_=POP_SIZE,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                cxpb=CXPB, mutpb=MUTPB, ngen=NGEN, verbose=False) # Set verbose to False to reduce output

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # === Extract Pareto-Optimal Solutions for Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Get the first front (non-dominated solutions) for this optimization run
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                pareto_front_impact = tools.sortNondominated(pop, k=len(pop), first_front_only=True)[0]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Store the Pareto front for this impact in the dictionary
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                pareto_fronts_by_impact[impact_col] = pareto_front_impact

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """## Collect and present results

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ### Subtask:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Gather the Pareto front solutions from all the optimization runs. For each impact category's Pareto front, display or summarize the trade-off between Total Cost and that specific impact.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                **Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Iterate through the stored Pareto fronts, extract the relevant objective values (Cost and the specific impact), and print them to illustrate the trade-offs for each impact category, highlighting the GWP vs Cost results.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print("\n--- Pareto Front Summaries (Cost vs. Specific TRACI Impact) ---")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Iterate through the stored Pareto fronts by impact category
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for impact_col, pareto_front in pareto_fronts_by_impact.items():
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print(f"\nOptimization for: {impact_col}")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Sort the Pareto front by Total Cost for better readability
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    sorted_pareto_front = sorted(pareto_front, key=lambda ind: ind.fitness.values[0])

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Extract Cost and the specific Impact values
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    costs = [ind.fitness.values[0] for ind in sorted_pareto_front]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    impact_values = [ind.fitness.values[1] for ind in sorted_pareto_front] # The second objective is the specific impact

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Display a summary or selection of solutions from the Pareto front
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print("  Trade-offs (Cost, Impact Value):")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Display the first few and the last few solutions to show the range of trade-offs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    display_count = min(5, len(sorted_pareto_front)) # Display up to 5 solutions

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if len(sorted_pareto_front) > 0:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for i in range(display_count):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            print(f"    Solution {i+1}: (Cost: {costs[i]:.2f}, {impact_col}: {impact_values[i]:.4f})")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if len(sorted_pareto_front) > display_count:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print("    ...")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Display the last solution
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print(f"    Solution {len(sorted_pareto_front)}: (Cost: {costs[-1]:.2f}, {impact_col}: {impact_values[-1]:.4f})")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                else:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print("    No non-dominated solutions found for this objective.")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Specifically highlight GWP vs Cost optimization
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if impact_col == 'kg CO2-Eq/Unit':
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        print("\n--- Highlight: Pareto Front for Global Warming Potential (GWP) vs. Total Cost ---")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for i in range(display_count):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            print(f"    Solution {i+1}: (Cost: {costs[i]:.2f}, GWP (kg CO2-Eq): {impact_values[i]:.4f})")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if len(sorted_pareto_front) > display_count:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print("    ...")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print(f"    Solution {len(sorted_pareto_front)}: (Cost: {costs[-1]:.2f}, GWP (kg CO2-Eq): {impact_values[-1]:.4f})")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print("---------------------------------------------------------------------------------")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print("\n--- End of Pareto Front Summaries ---")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """## Summary:

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ### Data Analysis Key Findings

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   The analysis successfully identified 9 TRACI impact categories: `kg SO2-Eq/Unit`, `kg CO2-Eq/Unit`, `CTUe/Unit`, `kg N-Eq/Unit`, `CTUh/Unit`, `CTUh/Unit.1`, `kg CFC-11-Eq/Unit`, `kg PM2.5-Eq/Unit`, and `kg O3-Eq/Unit`.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   For each of these 9 TRACI impact categories, a separate multi-objective optimization was performed using NSGA-II to find the Pareto front for minimizing Total Cost and the specific impact category, allowing material inputs to vary by +/- 20%.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   The Pareto fronts for each optimization run were successfully extracted and stored, demonstrating the trade-off between Total Cost and the respective environmental impact.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   The results for the Global Warming Potential (GWP) vs. Total Cost optimization were specifically highlighted, showing a range of non-dominated solutions. For example, some solutions offered lower GWP at potentially higher costs, while others offered lower costs with higher GWP.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ### Insights or Next Steps

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   The generated Pareto fronts provide a set of optimal trade-off solutions that decision-makers can use to select a material composition based on their priorities regarding cost and specific environmental impacts.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   Further analysis could involve visualizing these Pareto fronts (e.g., plotting Cost vs. Impact) to better understand the shape of the trade-off curve for each impact category and identify potential "knee points" representing good compromises.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Task
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Identify the most sensitive material inputs to Total Cost and each TRACI Impact category by varying each input by +/- 20% from its base amount while holding other inputs constant, and rank the inputs based on their influence on each objective.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ## Identify materials and base amounts

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ### Subtask:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Get the list of materials and their original base amounts from the `merged_df`.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ## Access cost and impact data

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ### Subtask:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Ensure access to the unit cost and impact data for each material.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                **Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Access the necessary columns from the merged_df and the original impact_df to prepare the cost and impact data for sensitivity analysis.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Access the 'Unit Cost ($)' column from the merged_df DataFrame
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                costs = merged_df['Unit Cost ($)'].values

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Identify the columns in merged_df that correspond to TRACI impact categories
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Ensure these columns are also present in the original impact_df to filter correctly
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                impact_columns = [col for col in merged_df.columns if col in impact_df.columns and col not in ['Material', 'Unit', 'Year']]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Extract the data from merged_df corresponding to the impact_columns
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                impact_matrix = merged_df[impact_columns].values

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Access the list of TRACI impact column names from the original impact_df
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                traci_impact_cols = [col for col in impact_df.columns if col not in ['Material', 'Unit']]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print("Costs array shape:", costs.shape)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print("Impact matrix shape:", impact_matrix.shape)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print("TRACI Impact Columns (from original impact_df):", traci_impact_cols)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print("Impact Columns (from merged_df):", impact_columns)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """## Calculate baseline objectives

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ### Subtask:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Calculate the Total Cost and each TRACI Impact for the original base material amounts. This will serve as a baseline for comparison in the sensitivity analysis.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                **Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Calculate the baseline cost and TRACI impacts using the base material amounts and the costs and impact matrix.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Calculate the baseline cost
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                baseline_cost = np.dot(base_amounts, costs)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Calculate the baseline impacts for each TRACI impact category
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                baseline_impacts = []
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for i in range(impact_matrix.shape[1]):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    baseline_impact = np.dot(base_amounts, impact_matrix[:, i])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    baseline_impacts.append(baseline_impact)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Print the baseline cost
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print(f"Baseline Total Cost: {baseline_cost:.2f}")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Print the baseline impacts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print("\nBaseline TRACI Impacts:")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    for i, impact_col in enumerate(traci_impact_cols):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Ensure the index is valid for baseline_impacts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if i < len(baseline_impacts):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            print(f"  {impact_col}: {baseline_impacts[i]:.4f}")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            else:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print(f"  {impact_col}: N/A (Impact data not available)")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """## Perform sensitivity analysis per input

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ### Subtask:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                For each material input, calculate the range of change in Total Cost and each TRACI Impact category when varying that input by +/- 20% from its base amount, while holding other inputs constant.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                **Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Initialize dictionaries to store sensitivity results and then iterate through each material to calculate the range of change in Total Cost and each TRACI Impact when varying that material's amount, storing these ranges in the respective dictionaries.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Initialize dictionaries to store the range of change for each objective
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                cost_sensitivity = {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                impact_sensitivity = {col: {} for col in traci_impact_cols}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Iterate through each material input by its index
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for i in range(len(materials)):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Get the base amount for the current material
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    base_amount = base_amounts[i]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Calculate lower and upper bounds for the current material (+/- 20%)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    lower_bound = max(0, base_amount * 0.8) # Ensure non-negativity
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    upper_bound = base_amount * 1.2

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Create temporary arrays for lower and upper bound scenarios
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Start with the base amounts array
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    lower_bound_amounts = np.copy(base_amounts)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    upper_bound_amounts = np.copy(base_amounts)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Set the amount for the current material to its lower and upper bounds
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    lower_bound_amounts[i] = lower_bound
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    upper_bound_amounts[i] = upper_bound

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # === Calculate Sensitivity for Total Cost ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Calculate Total Cost for lower and upper bound amounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    cost_at_lower_bound = np.dot(lower_bound_amounts, costs)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    cost_at_upper_bound = np.dot(upper_bound_amounts, costs)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Calculate the range of change in Total Cost
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    cost_range = abs(cost_at_upper_bound - cost_at_lower_bound)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Store the range of change in the cost sensitivity dictionary
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    cost_sensitivity[materials[i]] = cost_range

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # === Calculate Sensitivity for Each TRACI Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Iterate through each TRACI impact column by its index in impact_matrix
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    for j in range(impact_matrix.shape[1]):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        impact_col = traci_impact_cols[j]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Calculate the total impact for lower and upper bound amounts for the current impact category
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        impact_at_lower_bound = np.dot(lower_bound_amounts, impact_matrix[:, j])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        impact_at_upper_bound = np.dot(upper_bound_amounts, impact_matrix[:, j])

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Calculate the range of change in the current TRACI impact
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        impact_range = abs(impact_at_upper_bound - impact_at_lower_bound)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Store the range of change in the corresponding TRACI impact sensitivity dictionary
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        impact_sensitivity[impact_col][materials[i]] = impact_range

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Print a confirmation that the calculations are done
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        print("Sensitivity calculations completed for all materials and objectives.")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """**Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Rank the material inputs based on their influence (range of change) on Total Cost and each TRACI Impact category, and then print the top sensitive materials for each objective.


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Rank materials by their influence on Total Cost
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Sort the cost_sensitivity dictionary by values in descending order
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        sorted_cost_sensitivity = sorted(cost_sensitivity.items(), key=lambda item: item[1], reverse=True)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        print("\nTop Sensitive Materials for Total Cost:")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Print the top N materials (e.g., top 10)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        top_n = 10
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for material, sensitivity in sorted_cost_sensitivity[:top_n]:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            print(f"  {material}: {sensitivity:.4f}")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Rank materials by their influence on each TRACI Impact category
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            print("\nTop Sensitive Materials for Each TRACI Impact:")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            for impact_col, sensitivity_dict in impact_sensitivity.items():
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print(f"\n  {impact_col}:")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Sort the sensitivity dictionary for the current impact by values in descending order
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                sorted_impact_sensitivity = sorted(sensitivity_dict.items(), key=lambda item: item[1], reverse=True)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Print the top N materials for the current impact
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for material, sensitivity in sorted_impact_sensitivity[:top_n]:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print(f"    {material}: {sensitivity:.4f}")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print("\nRanking completed for all objectives.")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """## Summary:

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ### Data Analysis Key Findings

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   The baseline Total Cost for the product using the original material amounts was \$42.94.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   The baseline TRACI impacts for the product were calculated across nine categories, including 0.0148 kg SO2-Eq/Unit for acidification and 5.2125 kg CO2-Eq/Unit for global warming.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   The sensitivity analysis calculated the absolute range of change in Total Cost and each TRACI Impact category for each material input when its amount was varied by +/- 20\% from its base, holding other inputs constant.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   Materials were ranked based on the magnitude of this change, indicating their influence on Total Cost and each TRACI Impact category. The top sensitive materials for each objective were identified and presented.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ### Insights or Next Steps

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   Focus on the materials identified as highly sensitive to Total Cost and key TRACI impacts. These inputs offer the greatest potential for cost reduction or environmental impact mitigation through quantity optimization or material substitution.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *   Investigate the underlying reasons for the high sensitivity of the identified materials (e.g., high unit cost, large baseline amount, high impact per unit) to inform targeted improvement strategies.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ## Summary:

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ### Data Analysis Key Findings

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * The baseline Total Cost for the product using the original material amounts was calculated.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * The baseline TRACI impacts for the product were calculated across nine categories.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * A sensitivity analysis was performed for each material input by varying its amount by +/- 20% from its base amount while holding other inputs constant.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * The range of change in Total Cost and each TRACI Impact was calculated for each material variation.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * Materials were ranked based on the magnitude of this range of change, identifying the inputs that are most sensitive to each objective. The top sensitive materials for Total Cost and each TRACI impact category were presented.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ### Insights or Next Steps

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * The identified sensitive materials are crucial to focus on for potential cost reduction or environmental impact mitigation efforts, as small changes in their quantities have the largest effect on the respective objectives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * Further investigation into the properties (unit cost, impact factors) and baseline amounts of these sensitive materials can provide deeper insights into why they are so influential.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * Decision-makers can use this sensitivity information to prioritize which material inputs to focus on for optimization or substitution strategies based on their specific cost and environmental goals.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Task
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Visualize the optimal solutions for cost vs. each individual TRACI impact category, showing the Pareto front and the optimized amounts of the top 5 most sensitive inputs for each category based on the sensitivity analysis results from "Updated_Material_Optimization_Data.xlsx".

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ## Identify traci impact objectives

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ### Subtask:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Get the list of TRACI impact column names.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    **Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Extract the column names from the impact_df DataFrame that are not 'Material' or 'Unit' and store them in a list to identify the TRACI impact categories.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    traci_impact_cols = [col for col in impact_df.columns if col not in ['Material', 'Unit']]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print("TRACI Impact Columns:")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print(traci_impact_cols)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """## Access sensitivity results

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ### Subtask:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Ensure access to the calculated sensitivity rankings for each TRACI impact category.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    **Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Verify the presence and content of the `impact_sensitivity` dictionary to ensure the sensitivity rankings are accessible.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Check if impact_sensitivity dictionary exists and is not empty
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if 'impact_sensitivity' in locals() and impact_sensitivity:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        print("Access confirmed to impact_sensitivity dictionary.")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Optionally print keys to confirm contents match TRACI impacts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        print("Keys in impact_sensitivity:", list(impact_sensitivity.keys()))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        else:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            print("Error: impact_sensitivity dictionary not found or is empty.")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Check if traci_impact_cols list exists and is not empty
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if 'traci_impact_cols' in locals() and traci_impact_cols:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print("Access confirmed to traci_impact_cols list.")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print("Contents of traci_impact_cols:", traci_impact_cols)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                else:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print("Error: traci_impact_cols list not found or is empty.")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """## Iterate through impact objectives

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ### Subtask:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Loop through each identified TRACI impact column.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    **Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Iterate through the list of traci_impact_cols to prepare for processing each impact category individually.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Initialize a dictionary to store plots for each impact category (optional, for later display)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # impact_plots = {}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Loop through each identified TRACI impact column
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    for impact_col in traci_impact_cols:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        print(f"Processing impact category: {impact_col}")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # The subsequent steps for visualization and analysis will be performed inside this loop

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """**Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Within the loop for each impact category, perform the NSGA-II multi-objective optimization to find the Pareto front for minimizing Total Cost and the current specific TRACI impact.


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # === NSGA-II Setup for Cost vs. Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Attempt to delete previously created classes to avoid RuntimeWarning
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        try:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            del creator.FitnessMin
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            except AttributeError:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                try:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    del creator.Individual
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    except AttributeError:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        pass

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Create Fitness class with two objectives to minimize (Cost and current Impact)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        creator.create("FitnessMin", base.Fitness, weights=(-1.0, -1.0))

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Create Individual class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        creator.create("Individual", list, fitness=creator.FitnessMin)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Re-initialize toolbox for each optimization run to ensure a clean state
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        toolbox = base.Toolbox()

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Sensitivity bounds: +/- 20% of base amount (ensure non-negativity)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        low_bounds = base_amounts * 0.8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        high_bounds = base_amounts * 1.2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        low_bounds[low_bounds < 0] = 0

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Attribute generator: random value within bounds
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        def create_ind():
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            return [random.uniform(low, high) for low, high in zip(low_bounds, high_bounds)]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            toolbox.register("individual", tools.initIterate, creator.Individual, create_ind)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            toolbox.register("population", tools.initRepeat, list, toolbox.individual)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Define the evaluation function specifically for Cost and the current impact_col
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            def evaluate_cost_impact(individual):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Evaluates an individual based on Total Cost and a single TRACI impact category.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Ensure non-negativity of individual values
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                adjusted_amounts = np.maximum(0, np.array(individual))

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Calculate total cost
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                total_cost = np.dot(adjusted_amounts, costs)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Find the index for the current impact column within the *current* impact_columns list
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                try:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Ensure impact_columns is aligned with the current merged_df state
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    current_impact_columns = [col for col in merged_df.columns if col in impact_df.columns and col not in ['Material', 'Unit', 'Year']]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    impact_idx = current_impact_columns.index(impact_col)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Ensure impact_matrix is aligned with the current merged_df state and columns
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    current_impact_matrix = merged_df[current_impact_columns].values
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    total_impact = np.dot(adjusted_amounts, current_impact_matrix[:, impact_idx])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    except ValueError:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        print(f"Warning: '{impact_col}' not found in impact columns during evaluation. Impact will be 0.")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        total_impact = 0.0

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Return the two objective values as a tuple
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        return total_cost, total_impact

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Register the evaluate_cost_impact function with the toolbox
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        toolbox.register("evaluate", evaluate_cost_impact)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Register crossover and mutation operators (using standard DEAP ones for simplicity)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        toolbox.register("mate", tools.cxBlend, alpha=0.5)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=0.1, indpb=0.2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        toolbox.register("select", tools.selNSGA2) # Use NSGA-II selection for multi-objective

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # === Run NSGA-II Optimization for Cost vs. Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        pop = toolbox.population(n=POP_SIZE)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Evaluate the initial population
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        fitnesses = list(map(toolbox.evaluate, pop))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ind, fit in zip(pop, fitnesses):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ind.fitness.values = fit

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # This is the main NSGA-II algorithm
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            algorithms.eaMuPlusLambda(pop, toolbox, mu=POP_SIZE, lambda_=POP_SIZE,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            cxpb=CXPB, mutpb=MUTPB, ngen=NGEN, verbose=False) # Set verbose to False to reduce output

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # === Extract Pareto-Optimal Solutions for Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Get the first front (non-dominated solutions) for this optimization run
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            pareto_front_impact = tools.sortNondominated(pop, k=len(pop), first_front_only=True)[0]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Store the Pareto front for this impact in a dictionary
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            pareto_fronts_by_impact[impact_col] = pareto_front

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """**Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Within the loop for each impact category, after performing the NSGA-II optimization and extracting the Pareto front, identify the top 5 most sensitive materials based on the pre-calculated sensitivity analysis results.


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # === Identify Top Sensitive Materials for the Current Impact ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Ensure access to the impact_sensitivity dictionary
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if impact_col in impact_sensitivity:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                sensitivity_dict = impact_sensitivity[impact_col]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Sort the sensitivity dictionary for the current impact by values in descending order
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                sorted_impact_sensitivity = sorted(sensitivity_dict.items(), key=lambda item: item[1], reverse=True)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Get the names of the top 5 most sensitive materials
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                top_sensitive_materials = [material for material, sensitivity in sorted_impact_sensitivity[:5]]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print(f"  Top 5 Sensitive Materials for {impact_col}: {top_sensitive_materials}")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                else:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    top_sensitive_materials = []
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    print(f"  Warning: Sensitivity data not found for {impact_col}. Cannot identify top sensitive materials.")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # The next steps (visualization) will use the pareto_front_impact and top_sensitive_materials

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """**Reasoning**:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Visualize the Pareto front for the current TRACI impact category and plot the optimized amounts of the top 5 most sensitive inputs for solutions along the Pareto front to show the trade-offs.


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # === Visualize Pareto Front and Optimized Amounts ===
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if pareto_front_impact:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Extract Cost and the specific Impact values from the Pareto front
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        costs = [ind.fitness.values[0] for ind in pareto_front_impact]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        impact_values = [ind.fitness.values[1] for ind in pareto_front_impact] # The second objective is the specific impact

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Create a figure with two subplots
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 6))

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Plot the Pareto front (Cost vs. specific Impact)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ax1.scatter(costs, impact_values, marker='o', color='b', label='Pareto Front Solutions')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ax1.set_title(f'Pareto Front: Total Cost vs. {impact_col}')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ax1.set_xlabel('Total Cost ($)')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ax1.set_ylabel(impact_col)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ax1.grid(True)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ax1.legend()

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Plot optimized amounts of top sensitive materials across the Pareto front
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ax2.set_title(f'Optimized Amounts of Top 5 Sensitive Materials for {impact_col}')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ax2.set_xlabel('Pareto Front Solution Index (Sorted by Cost)')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ax2.set_ylabel('Optimized Amount')

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Extract optimized amounts for top sensitive materials across the sorted Pareto front
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        sorted_pareto_front = sorted(pareto_front_impact, key=lambda ind: ind.fitness.values[0])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        optimized_amounts_for_plot = {material: [] for material in top_sensitive_materials}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Find the indices of the top sensitive materials in the materials list
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        top_sensitive_indices = [materials.index(mat) for mat in top_sensitive_materials if mat in materials]

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ind in sorted_pareto_front:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            for idx in top_sensitive_indices:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                optimized_amounts_for_plot[materials[idx]].append(ind[idx])

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Plot the optimized amounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for material in top_sensitive_materials:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if material in optimized_amounts_for_plot: # Check if data was collected for this material
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ax2.plot(range(len(sorted_pareto_front)), optimized_amounts_for_plot[material], marker='.', linestyle='-', label=material)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ax2.legend(title="Material", bbox_to_anchor=(1.05, 1), loc='upper left')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ax2.grid(True)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        plt.tight_layout(rect=[0, 0, 0.85, 1]) # Adjust layout to make space for the legend outside
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        plt.show()

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        else:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            print(f"  No Pareto front solutions found for {impact_col} to visualize.")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """## Summary:

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ### Data Analysis Key Findings

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   The analysis successfully identified the TRACI impact categories from the `impact_df` DataFrame.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   The NSGA-II multi-objective optimization algorithm was applied iteratively for each TRACI impact category against total cost.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   For each TRACI impact category, the Pareto front representing the non-dominated solutions for cost and the specific impact was successfully extracted.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   The top 5 most sensitive materials were identified for each TRACI impact category based on the provided sensitivity analysis data.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   Visualizations were generated for each TRACI impact category showing the Pareto front (Cost vs. Impact) and the optimized amounts of the top 5 most sensitive materials across the Pareto front solutions.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ### Insights or Next Steps

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   Analyze the generated plots to understand the specific trade-offs between total cost and each TRACI impact category and how the amounts of sensitive materials change along the Pareto front.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   Use the insights from the Pareto fronts and sensitive material analysis to inform decision-making on material selection and amounts based on desired cost and environmental performance targets.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """